
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/invariant.rs" 16 4 16 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Vecmap_VecMap_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_vecmap 'k 'v =
    | C_VecMap (Alloc_Vec_Vec_Type.t_vec ('k, 'v) (Alloc_Alloc_Global_Type.t_global))
    
  let function vecmap_v (self : t_vecmap 'k 'v) : Alloc_Vec_Vec_Type.t_vec ('k, 'v) (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VecMap a -> a
      end
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs" 49 8 49 27] (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Model_DeepModel_DeepModelTy_Type
  type self
  type deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Stub
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Interface
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_DeepModel_DeepModel
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module Vecmap_Impl0_KeySeq_Stub
  type k
  type v
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  function key_seq [#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 4 57 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
end
module Vecmap_Impl0_KeySeq_Interface
  type k
  type v
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  function key_seq [#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 4 57 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
  val key_seq [#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 4 57 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 15 57 19] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 54 4 56 56] Seq.length result = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get result i = DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 24 57 43] Inv1.inv result }
    ensures { result = key_seq self }
    
  axiom key_seq_spec : forall self : Vecmap_VecMap_Type.t_vecmap k v . ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 15 57 19] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 24 57 43] Inv1.inv (key_seq self)) && ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 54 4 56 56] Seq.length (key_seq self) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (key_seq self) i = DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a)))
end
module Vecmap_Impl0_KeySeq
  type k
  type v
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  function key_seq [#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 4 57 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
  val key_seq [#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 4 57 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 15 57 19] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 54 4 56 56] Seq.length result = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get result i = DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 24 57 43] Inv1.inv result }
    ensures { result = key_seq self }
    
  axiom key_seq_spec : forall self : Vecmap_VecMap_Type.t_vecmap k v . ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 15 57 19] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 57 24 57 43] Inv1.inv (key_seq self)) && ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 54 4 56 56] Seq.length (key_seq self) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (key_seq self) i = DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a)))
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
  val cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self _2 }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
  val cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self _2 }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub
  type self
  function lt_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface
  type self
  function lt_log (self : self) (o : self) : bool
  val lt_log (self : self) (o : self) : bool
    ensures { result = lt_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function lt_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 21 20 21 53] CmpLog0.cmp_log self o = Core_Cmp_Ordering_Type.C_Less
  val lt_log (self : self) (o : self) : bool
    ensures { result = lt_log self o }
    
end
module Vecmap_Impl0_IsSorted_Stub
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_sorted [#"/mnt/data/projects/creusot/examples/vecmap.rs" 62 4 62 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
end
module Vecmap_Impl0_IsSorted_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_sorted [#"/mnt/data/projects/creusot/examples/vecmap.rs" 62 4 62 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
  val is_sorted [#"/mnt/data/projects/creusot/examples/vecmap.rs" 62 4 62 30] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = is_sorted self }
    
end
module Vecmap_Impl0_IsSorted
  type k
  type v
  use prelude.Int
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv1.inv,
    axiom .
  predicate is_sorted [#"/mnt/data/projects/creusot/examples/vecmap.rs" 62 4 62 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 63 8 66 9] forall n : int . forall m : int . m >= 0 /\ n >= 0 /\ m < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ n < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ m < n -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) m) (Seq.get (KeySeq0.key_seq self) n)
  val is_sorted [#"/mnt/data/projects/creusot/examples/vecmap.rs" 62 4 62 30] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = is_sorted self }
    
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  val new (_1 : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 68 26 68 44] Seq.length (ShallowModel0.shallow_model result) = 0 }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 420 4 420 30] Inv0.inv result }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module Vecmap_Impl1_New_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val new [#"/mnt/data/projects/creusot/examples/vecmap.rs" 75 4 75 24] (_1 : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 75 20 75 24] Inv0.inv result }
    
end
module Vecmap_Impl1_New
  type k
  type v
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv
  let rec cfg new [#"/mnt/data/projects/creusot/examples/vecmap.rs" 75 4 75 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 75 20 75 24] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_VecMap_Type.t_vecmap k v;
  var _1 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    _1 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 76 18 76 28] New0.new ());
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_VecMap_Type.C_VecMap _1;
    _1 <- any Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_OccupiedEntry_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  type t_occupiedentry 'k 'v =
    | C_OccupiedEntry (borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)) 'k usize
    
  let function occupiedentry_map (self : t_occupiedentry 'k 'v) : borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry a _ _ -> a
      end
  let function occupiedentry_index (self : t_occupiedentry 'k 'v) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry _ _ a -> a
      end
  let function occupiedentry_key (self : t_occupiedentry 'k 'v) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry _ a _ -> a
      end
end
module Vecmap_VacantEntry_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  type t_vacantentry 'k 'v =
    | C_VacantEntry (borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)) 'k usize
    
  let function vacantentry_map (self : t_vacantentry 'k 'v) : borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry a _ _ -> a
      end
  let function vacantentry_index (self : t_vacantentry 'k 'v) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry _ _ a -> a
      end
  let function vacantentry_key (self : t_vacantentry 'k 'v) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry _ a _ -> a
      end
end
module Vecmap_Entry_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  type t_entry 'k 'v =
    | C_Vacant (Vecmap_VacantEntry_Type.t_vacantentry 'k 'v)
    | C_Occupied (Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v)
    
  let function vacant_0 (self : t_entry 'k 'v) : Vecmap_VacantEntry_Type.t_vacantentry 'k 'v
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Vacant a -> a
      | C_Occupied _ -> any Vecmap_VacantEntry_Type.t_vacantentry 'k 'v
      end
  let function occupied_0 (self : t_entry 'k 'v) : Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Vacant _ -> any Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v
      | C_Occupied a -> a
      end
end
module Vecmap_Impl8_Invariant_Stub
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 493 4 493 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
    
end
module Vecmap_Impl8_Invariant_Interface
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 493 4 493 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
    
  val invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 493 4 493 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_Impl8_Invariant
  type k
  type v
  use prelude.Borrow
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv1.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 493 4 493 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 494 8 498 9] IsSorted0.is_sorted ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self))) > UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index self) /\ Seq.get (KeySeq0.key_seq ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self)) (UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index self)) = DeepModel0.deep_model (Vecmap_OccupiedEntry_Type.occupiedentry_key self)
  val invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 493 4 493 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_Impl6_Invariant_Stub
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 461 4 461 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
end
module Vecmap_Impl6_Invariant_Interface
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 461 4 461 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
  val invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 461 4 461 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_Impl6_Invariant
  type k
  type v
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 461 4 461 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 462 8 464 9] IsSorted0.is_sorted ( * Vecmap_VacantEntry_Type.vacantentry_map self) /\ UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self)))
  val invariant' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 461 4 461 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module Core_Result_Result_Type
  type t_result 't 'e =
    | C_Ok 't
    | C_Err 'e
    
  let function ok_0 (self : t_result 't 'e) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ok a -> a
      | C_Err _ -> any 't
      end
  let function err_0 (self : t_result 't 'e) : 'e = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ok _ -> any 'e
      | C_Err a -> a
      end
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_Impl4_DeepModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_Impl4_DeepModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_Impl4_DeepModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = t,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model (self : t) : DeepModelTy0.deepModelTy =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/model.rs" 74 8 74 28] DeepModel0.deep_model self
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Contains_Stub
  type t
  use seq.Seq
  predicate contains (self : Seq.seq t) (e : t)
end
module CreusotContracts_Logic_Seq_Impl0_Contains_Interface
  type t
  use seq.Seq
  predicate contains (self : Seq.seq t) (e : t)
  val contains (self : Seq.seq t) (e : t) : bool
    ensures { result = contains self e }
    
end
module CreusotContracts_Logic_Seq_Impl0_Contains
  type t
  use seq.Seq
  use prelude.Int
  predicate contains (self : Seq.seq t) (e : t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/seq.rs" 128 8 128 78] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = e
  val contains (self : Seq.seq t) (e : t) : bool
    ensures { result = contains self e }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub
  type self
  function gt_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface
  type self
  function gt_log (self : self) (o : self) : bool
  val gt_log (self : self) (o : self) : bool
    ensures { result = gt_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function gt_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 41 20 41 56] CmpLog0.cmp_log self o = Core_Cmp_Ordering_Type.C_Greater
  val gt_log (self : self) (o : self) : bool
    ensures { result = gt_log self o }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl5_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/model.rs" 83 8 83 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  val len (self : Alloc_Vec_Vec_Type.t_vec t a) : usize
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2049 16 2049 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 75 26 75 48] UIntSize.to_int result = Seq.length (ShallowModel0.shallow_model self) }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module Alloc_Vec_Impl12_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 141 27 141 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2673 14 2673 18] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2673 20 2673 25] Inv1.inv index}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 142 26 142 54] HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2673 4 2673 46] Inv2.inv result }
    
end
module Core_Cmp_Ord_Cmp_Interface
  type self
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  val cmp (self : self) (other : self) : Core_Cmp_Ordering_Type.t_ordering
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 775 12 775 16] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 775 18 775 23] Inv0.inv other}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/cmp.rs" 44 26 44 85] result = CmpLog0.cmp_log (DeepModel0.deep_model self) (DeepModel0.deep_model other) }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub
  type self
  function le_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface
  type self
  function le_log (self : self) (o : self) : bool
  val le_log (self : self) (o : self) : bool
    ensures { result = le_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function le_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 11 20 11 56] CmpLog0.cmp_log self o <> Core_Cmp_Ordering_Type.C_Greater
  val le_log (self : self) (o : self) : bool
    ensures { result = le_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_le_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_le_log (x : self) (y : self) : ()
  val cmp_le_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater) }
    ensures { result = cmp_le_log x y }
    
  axiom cmp_le_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_le_log (x : self) (y : self) : ()
  val cmp_le_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater) }
    ensures { result = cmp_le_log x y }
    
  axiom cmp_le_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_lt_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_lt_log (x : self) (y : self) : ()
  val cmp_lt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) }
    ensures { result = cmp_lt_log x y }
    
  axiom cmp_lt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_lt_log (x : self) (y : self) : ()
  val cmp_lt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) }
    ensures { result = cmp_lt_log x y }
    
  axiom cmp_lt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub
  type self
  function ge_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface
  type self
  function ge_log (self : self) (o : self) : bool
  val ge_log (self : self) (o : self) : bool
    ensures { result = ge_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function ge_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 31 20 31 53] CmpLog0.cmp_log self o <> Core_Cmp_Ordering_Type.C_Less
  val ge_log (self : self) (o : self) : bool
    ensures { result = ge_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_ge_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_ge_log (x : self) (y : self) : ()
  val cmp_ge_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less) }
    ensures { result = cmp_ge_log x y }
    
  axiom cmp_ge_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_ge_log (x : self) (y : self) : ()
  val cmp_ge_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less) }
    ensures { result = cmp_ge_log x y }
    
  axiom cmp_ge_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_gt_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_gt_log (x : self) (y : self) : ()
  val cmp_gt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) }
    ensures { result = cmp_gt_log x y }
    
  axiom cmp_gt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_gt_log (x : self) (y : self) : ()
  val cmp_gt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) }
    ensures { result = cmp_gt_log x y }
    
  axiom cmp_gt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function refl (x : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function refl (x : self) : ()
  val refl (x : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal }
    ensures { result = refl x }
    
  axiom refl_spec : forall x : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal)
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function refl (x : self) : ()
  val refl (x : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal }
    ensures { result = refl x }
    
  axiom refl_spec : forall x : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal)
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
  val trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o }
    ensures { result = trans x y z o }
    
  axiom trans_spec : forall x : self, y : self, z : self, o : Core_Cmp_Ordering_Type.t_ordering . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o)
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
  val trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o }
    ensures { result = trans x y z o }
    
  axiom trans_spec : forall x : self, y : self, z : self, o : Core_Cmp_Ordering_Type.t_ordering . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
  val antisym1 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater }
    ensures { result = antisym1 x y }
    
  axiom antisym1_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
  val antisym1 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater }
    ensures { result = antisym1 x y }
    
  axiom antisym1_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
  val antisym2 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less }
    ensures { result = antisym2 x y }
    
  axiom antisym2_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
  val antisym2 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less }
    ensures { result = antisym2 x y }
    
  axiom antisym2_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function eq_cmp (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function eq_cmp (x : self) (y : self) : ()
  val eq_cmp (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal) }
    ensures { result = eq_cmp x y }
    
  axiom eq_cmp_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal))
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function eq_cmp (x : self) (y : self) : ()
  val eq_cmp (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal) }
    ensures { result = eq_cmp x y }
    
  axiom eq_cmp_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal))
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 108 20 108 37] UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 115 20 115 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module Vecmap_Impl1_FindK_Interface
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val find_k [#"/mnt/data/projects/creusot/examples/vecmap.rs" 311 4 311 53] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Result_Result_Type.t_result usize usize
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 297 15 297 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 311 15 311 19] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 311 21 311 24] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 298 14 301 5] match (result) with
      | Core_Result_Result_Type.C_Ok _ -> Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      | Core_Result_Result_Type.C_Err _ -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      end }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 302 4 302 91] forall i : usize . result = Core_Result_Result_Type.C_Ok i -> Seq.get (KeySeq0.key_seq self) (UIntSize.to_int i) = DeepModel0.deep_model key }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 303 4 304 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i -> j >= UIntSize.to_int i /\ j < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 305 4 306 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i /\ j >= 0 /\ j < UIntSize.to_int i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 307 14 310 5] match (result) with
      | Core_Result_Result_Type.C_Ok idx -> UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      | Core_Result_Result_Type.C_Err idx -> UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      end }
    
end
module Vecmap_Impl1_FindK
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = usize,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv6.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Cmp_Ord_Cmp_Interface as Cmp0 with
    type self = k,
    predicate Inv0.inv = Inv0.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v)
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg find_k [#"/mnt/data/projects/creusot/examples/vecmap.rs" 311 4 311 53] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Result_Result_Type.t_result usize usize
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 297 15 297 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 311 15 311 19] Inv1.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 311 21 311 24] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 298 14 301 5] match (result) with
      | Core_Result_Result_Type.C_Ok _ -> Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      | Core_Result_Result_Type.C_Err _ -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      end }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 302 4 302 91] forall i : usize . result = Core_Result_Result_Type.C_Ok i -> Seq.get (KeySeq0.key_seq self) (UIntSize.to_int i) = DeepModel0.deep_model key }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 303 4 304 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i -> j >= UIntSize.to_int i /\ j < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 305 4 306 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i /\ j >= 0 /\ j < UIntSize.to_int i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 307 14 310 5] match (result) with
      | Core_Result_Result_Type.C_Ok idx -> UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      | Core_Result_Result_Type.C_Err idx -> UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Result_Result_Type.t_result usize usize;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : k = key;
  var size : usize;
  var left : usize;
  var right : usize;
  var mid : usize;
  var _29 : bool;
  var cmp : Core_Cmp_Ordering_Type.t_ordering;
  var _32 : (k, v);
  var _36 : ();
  {
    goto BB0
  }
  BB0 {
    size <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 312 23 312 35] Len0.len (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    left <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 313 23 313 24] (0 : usize));
    right <- size;
    goto BB2
  }
  BB2 {
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 317 20 317 58] UIntSize.to_int size >= 0 /\ UIntSize.to_int size <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 318 20 318 58] UIntSize.to_int left >= 0 /\ UIntSize.to_int left <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 319 20 319 60] UIntSize.to_int right >= 0 /\ UIntSize.to_int right <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 317 8 317 60] UIntSize.to_int left < UIntSize.to_int right -> UIntSize.to_int left + div (UIntSize.to_int size) 2 < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 317 8 317 60] UIntSize.to_int left < UIntSize.to_int right -> UIntSize.to_int right > UIntSize.to_int left + div (UIntSize.to_int size) 2 };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 317 8 317 60] forall i : int . i >= UIntSize.to_int right /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model key) };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 317 8 317 60] forall i : int . i >= 0 /\ i < UIntSize.to_int left -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model key) };
    goto BB3
  }
  BB3 {
    switch ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 326 14 326 26] left < right)
      | False -> goto BB15
      | True -> goto BB4
      end
  }
  BB4 {
    _29 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 327 25 327 33] ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 327 32 327 33] (2 : usize)) = ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 327 25 327 33] (0 : usize)));
    assert { [@expl:division by zero] [#"/mnt/data/projects/creusot/examples/vecmap.rs" 327 25 327 33] not _29 };
    goto BB5
  }
  BB5 {
    mid <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 327 12 327 33] left + ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 327 25 327 33] size / ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 327 32 327 33] (2 : usize))));
    _32 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 329 22 329 33] Index0.index (Vecmap_VecMap_Type.vecmap_v self) mid);
    goto BB6
  }
  BB6 {
    assert { [@expl:type invariant] Inv2.inv _32 };
    assume { Resolve2.resolve _32 };
    cmp <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 329 22 329 44] Cmp0.cmp (let (a, _) = _32 in a) key);
    goto BB7
  }
  BB7 {
    switch (cmp)
      | Core_Cmp_Ordering_Type.C_Less -> goto BB8
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB9
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB10
      end
  }
  BB8 {
    goto BB12
  }
  BB9 {
    _0 <- Core_Result_Result_Type.C_Ok mid;
    goto BB16
  }
  BB10 {
    goto BB13
  }
  BB11 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB12 {
    left <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 332 34 332 48] mid + ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 332 47 332 48] (1 : usize)));
    _36 <- ();
    goto BB14
  }
  BB13 {
    right <- mid;
    _36 <- ();
    goto BB14
  }
  BB14 {
    size <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 337 12 337 31] right - left);
    goto BB2
  }
  BB15 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Result_Result_Type.C_Err left;
    goto BB16
  }
  BB16 {
    return _0
  }
  BB18 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    goto BB9
  }
  BB19 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    goto BB9
  }
  
end
module Vecmap_OccupiedEntry_Type_Inv
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = k
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  axiom inv_t_occupiedentry [@rewrite] : forall self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . Inv0.inv self = ((Inv1.inv ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self) /\ Inv1.inv ( ^ Vecmap_OccupiedEntry_Type.occupiedentry_map self)) /\ Inv2.inv (Vecmap_OccupiedEntry_Type.occupiedentry_key self))
end
module Vecmap_VacantEntry_Type_Inv
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = k
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  axiom inv_t_vacantentry [@rewrite] : forall self : Vecmap_VacantEntry_Type.t_vacantentry k v . Inv0.inv self = ((Inv1.inv ( * Vecmap_VacantEntry_Type.vacantentry_map self) /\ Inv1.inv ( ^ Vecmap_VacantEntry_Type.vacantentry_map self)) /\ Inv2.inv (Vecmap_VacantEntry_Type.vacantentry_key self))
end
module Vecmap_Entry_Type_Inv
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_Entry_Type.t_entry k v
  axiom inv_t_entry [@rewrite] : forall self : Vecmap_Entry_Type.t_entry k v . Inv0.inv self = match (self) with
    | Vecmap_Entry_Type.C_Vacant a_0 -> Inv1.inv (Vecmap_Entry_Type.vacant_0 self)
    | Vecmap_Entry_Type.C_Occupied a_0 -> Inv2.inv (Vecmap_Entry_Type.occupied_0 self)
    end
end
module Vecmap_Impl1_Entry_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Vecmap_Entry_Type.t_entry k v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl6_Invariant_Stub as Invariant1 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val entry [#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 4 84 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 81 15 81 31] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 22 84 26] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 28 84 31] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 82 4 82 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . Inv2.inv e -> result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 83 4 83 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . Inv3.inv e -> result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 39 84 50] Inv4.inv result }
    
end
module Vecmap_Impl1_Entry
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone Vecmap_Entry_Type_Inv as Vecmap_Entry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv3.inv,
    axiom .
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv3.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    predicate Inv2.inv = Inv1.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl6_Invariant as Invariant1 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    predicate Inv2.inv = Inv1.inv,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv2.inv = Inv1.inv,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv10.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg entry [#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 4 84 50] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 81 15 81 31] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 22 84 26] Inv2.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 28 84 31] Inv3.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 82 4 82 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . Inv4.inv e -> result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 83 4 83 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . Inv5.inv e -> result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 84 39 84 50] Inv6.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_Entry_Type.t_entry k v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key : k = key;
  var _6 : Core_Result_Result_Type.t_result usize usize;
  var _9 : k;
  var index : usize;
  var _13 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var index1 : usize;
  var _18 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  {
    goto BB0
  }
  BB0 {
    _9 <- key;
    assert { [@expl:type invariant] Inv0.inv _9 };
    assume { Resolve0.resolve _9 };
    _6 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 85 14 85 31] FindK0.find_k ( * self) _9);
    goto BB1
  }
  BB1 {
    switch (_6)
      | Core_Result_Result_Type.C_Ok _ -> goto BB2
      | Core_Result_Result_Type.C_Err _ -> goto BB3
      end
  }
  BB2 {
    goto BB5
  }
  BB3 {
    index1 <- Core_Result_Result_Type.err_0 _6;
    _18 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _18) };
    assume { Inv1.inv ( ^ _18) };
    goto BB8
  }
  BB4 {
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve2.resolve key };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB5 {
    index <- Core_Result_Result_Type.ok_0 _6;
    _13 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _13) };
    assume { Inv1.inv ( ^ _13) };
    goto BB6
  }
  BB6 {
    _0 <- Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry _13 key index);
    _13 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB7
  }
  BB7 {
    goto BB10
  }
  BB8 {
    _0 <- Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry _18 key index1);
    _18 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    return _0
  }
  
end
module Vecmap_KeyRef_Type
  use prelude.Int
  use prelude.UIntSize
  type t_keyref 'k =
    | C_KeyRef 'k usize
    
  let function keyref_key (self : t_keyref 'k) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_KeyRef a _ -> a
      end
  let function keyref_min_idx (self : t_keyref 'k) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_KeyRef _ a -> a
      end
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module CreusotContracts_Logic_Seq_Impl0_Get_Stub
  type t
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
end
module CreusotContracts_Logic_Seq_Impl0_Get_Interface
  type t
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
  val get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
    ensures { result = get self ix }
    
end
module CreusotContracts_Logic_Seq_Impl0_Get
  type t
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/seq.rs" 23 4 23 12] if 0 <= ix /\ ix < Seq.length self then
      Core_Option_Option_Type.C_Some (Seq.get self ix)
    else
      Core_Option_Option_Type.C_None
    
  val get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
    ensures { result = get self ix }
    
end
module Vecmap_Impl1_IsValidKeyrefLg_Stub
  type k
  type v
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  predicate is_valid_keyref_lg [#"/mnt/data/projects/creusot/examples/vecmap.rs" 254 4 254 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
end
module Vecmap_Impl1_IsValidKeyrefLg_Interface
  type k
  type v
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  predicate is_valid_keyref_lg [#"/mnt/data/projects/creusot/examples/vecmap.rs" 254 4 254 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
  val is_valid_keyref_lg [#"/mnt/data/projects/creusot/examples/vecmap.rs" 254 4 254 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 253 15 253 31] IsSorted0.is_sorted self}
    ensures { result = is_valid_keyref_lg self key }
    
end
module Vecmap_Impl1_IsValidKeyrefLg
  type k
  type v
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get_Stub as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv1.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  predicate is_valid_keyref_lg [#"/mnt/data/projects/creusot/examples/vecmap.rs" 254 4 254 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 256 12 261 13] match (Get0.get (KeySeq0.key_seq self) (UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key))) with
      | Core_Option_Option_Type.C_Some k -> LeLog0.le_log k (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))
      | _ -> false
      end
  val is_valid_keyref_lg [#"/mnt/data/projects/creusot/examples/vecmap.rs" 254 4 254 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 253 15 253 31] IsSorted0.is_sorted self}
    ensures { result = is_valid_keyref_lg self key }
    
end
module Vecmap_Impl1_IsValidKeyrefLg_Impl
  type k
  type v
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv4.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv4.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv4.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv4.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv4.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv4.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv1.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv2.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec ghost predicate is_valid_keyref_lg [#"/mnt/data/projects/creusot/examples/vecmap.rs" 254 4 254 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 253 15 253 31] IsSorted0.is_sorted self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 256 12 261 13] match (let a' = KeySeq0.key_seq self in Get0.get a' (UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key))) with
      | Core_Option_Option_Type.C_Some k -> let b' = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key) in LeLog0.le_log k b'
      | _ -> false
      end
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
  val produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = produces self visited o }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces
  type idx
  use seq.Seq
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
   =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 21 8 27 9] Core_Ops_Range_Range_Type.range_end self = Core_Ops_Range_Range_Type.range_end o /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) /\ (Seq.length visited > 0 -> DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end o)) /\ Seq.length visited = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) - DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> DeepModel0.deep_model (Seq.get visited i) = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) + i)
  val produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = produces self visited o }
    
end
module Vecmap_Impl10_DeepModel_Stub
  type k
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"/mnt/data/projects/creusot/examples/vecmap.rs" 537 4 537 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
end
module Vecmap_Impl10_DeepModel_Interface
  type k
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"/mnt/data/projects/creusot/examples/vecmap.rs" 537 4 537 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
  val deep_model [#"/mnt/data/projects/creusot/examples/vecmap.rs" 537 4 537 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    ensures { result = deep_model self }
    
end
module Vecmap_Impl10_DeepModel
  type k
  use prelude.Int
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"/mnt/data/projects/creusot/examples/vecmap.rs" 537 4 537 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 538 19 538 57] (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key self), UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx self))
  val deep_model [#"/mnt/data/projects/creusot/examples/vecmap.rs" 537 4 537 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    ensures { result = deep_model self }
    
end
module Vecmap_Impl12_AsRef_Interface
  type k
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, int)
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  val as_ref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 552 4 552 38] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 552 19 552 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 551 14 551 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 552 28 552 38] Inv1.inv result }
    
end
module Vecmap_Impl12_AsRef
  type k
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel4 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel3 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Vecmap_Impl10_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl10_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, int),
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg as_ref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 552 4 552 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 552 19 552 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 551 14 551 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 552 28 552 38] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_KeyRef_Type.t_keyref k = self;
  var _5 : k;
  {
    goto BB0
  }
  BB0 {
    _5 <- Vecmap_KeyRef_Type.keyref_key self;
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv _5 };
    assume { Resolve1.resolve _5 };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _5 (Vecmap_KeyRef_Type.keyref_min_idx self);
    return _0
  }
  
end
module Vecmap_Impl13_ToOwned_Stub
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  function to_owned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 4 560 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
end
module Vecmap_Impl13_ToOwned_Interface
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  function to_owned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 4 560 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
  val to_owned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 4 560 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 16 560 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 559 14 559 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 25 560 34] Inv1.inv result }
    ensures { result = to_owned self }
    
  axiom to_owned_spec : forall self : Vecmap_KeyRef_Type.t_keyref k . ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 16 560 20] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 25 560 34] Inv1.inv (to_owned self)) && ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 559 14 559 54] DeepModel0.deep_model self = DeepModel1.deep_model (to_owned self))
end
module Vecmap_Impl13_ToOwned
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  function to_owned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 4 560 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 561 8 561 56] Vecmap_KeyRef_Type.C_KeyRef (Vecmap_KeyRef_Type.keyref_key self) (Vecmap_KeyRef_Type.keyref_min_idx self)
  val to_owned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 4 560 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 16 560 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 559 14 559 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 25 560 34] Inv1.inv result }
    ensures { result = to_owned self }
    
  axiom to_owned_spec : forall self : Vecmap_KeyRef_Type.t_keyref k . ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 16 560 20] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 25 560 34] Inv1.inv (to_owned self)) && ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 559 14 559 54] DeepModel0.deep_model self = DeepModel1.deep_model (to_owned self))
end
module Vecmap_Impl13_ToOwned_Impl
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel3 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel2 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl10_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Vecmap_Impl10_DeepModel as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model
  let rec ghost function to_owned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 4 560 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 16 560 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 559 14 559 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 560 25 560 34] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 561 8 561 56] Vecmap_KeyRef_Type.C_KeyRef (Vecmap_KeyRef_Type.keyref_key self) (Vecmap_KeyRef_Type.keyref_min_idx self)
end
module Alloc_Vec_Impl8_Deref_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = slice t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  val deref (self : Alloc_Vec_Vec_Type.t_vec t a) : slice t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2608 14 2608 18] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 147 26 147 42] ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2608 4 2608 27] Inv1.inv result }
    
end
module Core_Slice_Impl0_Get_Interface
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val get (self : slice t) (index : i) : Core_Option_Option_Type.t_option Output0.output
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 601 19 601 23] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 601 25 601 30] Inv1.inv index}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 245 8 245 102] InBounds0.in_bounds index (ShallowModel0.shallow_model self) -> (exists r : Output0.output . Inv2.inv r /\ result = Core_Option_Option_Type.C_Some r /\ HasValue0.has_value index (ShallowModel0.shallow_model self) r) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 246 18 246 55] InBounds0.in_bounds index (ShallowModel0.shallow_model self) \/ result = Core_Option_Option_Type.C_None }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 601 4 603 28] Inv3.inv result }
    
end
module Core_Cmp_Impls_Impl10_Le_Interface
  type a
  type b
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel1 with
    type t = b,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = b
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = a
  val le (self : a) (other : b) : bool
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1470 15 1470 19] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1470 21 1470 26] Inv1.inv other}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/cmp.rs" 30 26 30 77] result = LeLog0.le_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] result = Slice.id self }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] result = Slice.id self }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module Vecmap_Impl1_IsValidKeyref_Interface
  type k
  type v
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel3 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone Vecmap_Impl1_IsValidKeyrefLg_Stub as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    axiom .
  clone Vecmap_Impl13_ToOwned_Stub as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv2.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val is_valid_keyref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 245 4 245 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 240 15 240 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 245 24 245 28] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 245 30 245 33] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 241 14 241 66] result = IsValidKeyrefLg0.is_valid_keyref_lg self (ToOwned0.to_owned key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 242 4 242 57] result -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 243 4 244 57] result -> (forall i : int . i >= 0 /\ i <= UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    
end
module Vecmap_Impl1_IsValidKeyref
  type k
  type v
  use prelude.Borrow
  use prelude.Slice
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial16 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial15 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial14 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = k,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = (k, v),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel3 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get1 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel2 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel as DeepModel4 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone Vecmap_Impl10_DeepModel as DeepModel3 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = k,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = slice (k, v),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv11.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    predicate Inv1.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv10.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    predicate Inv2.inv = Inv11.inv,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    predicate Inv3.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get1.get,
    predicate Inv0.inv = Inv11.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv1.inv = Inv12.inv,
    predicate Inv2.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv10.inv,
    axiom .
  clone Vecmap_Impl13_ToOwned as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv13.inv,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    function DeepModel1.deep_model = DeepModel4.deep_model,
    predicate Inv1.inv = Inv14.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = k
  clone Core_Cmp_Impls_Impl10_Le_Interface as Le0 with
    type a = k,
    type b = k,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv8.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = (k, v),
    type i = usize,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = (k, v),
    predicate Inv2.inv = Inv7.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv3.inv = Inv2.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = slice (k, v)
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    predicate Inv1.inv = Inv1.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg is_valid_keyref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 245 4 245 55] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 240 15 240 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 245 24 245 28] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 245 30 245 33] Inv3.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 241 14 241 66] result = IsValidKeyrefLg0.is_valid_keyref_lg self (ToOwned0.to_owned key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 242 4 242 57] result -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 243 4 244 57] result -> (forall i : int . i >= 0 /\ i <= UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : Vecmap_KeyRef_Type.t_keyref k = key;
  var _7 : Core_Option_Option_Type.t_option (k, v);
  var _9 : slice (k, v);
  var k : k;
  var _16 : k;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _9 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 246 14 246 37] Deref0.deref (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv _9 };
    assume { Resolve1.resolve _9 };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 246 14 246 37] Get0.get _9 (Vecmap_KeyRef_Type.keyref_min_idx key));
    goto BB2
  }
  BB2 {
    switch (_7)
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      | _ -> goto BB3
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv _7 };
    assume { Resolve2.resolve _7 };
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    _0 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 248 17 248 22] false);
    goto BB7
  }
  BB4 {
    goto BB5
  }
  BB5 {
    k <- (let (a, _) = Core_Option_Option_Type.some_0 _7 in a);
    assert { [@expl:type invariant] Inv2.inv _7 };
    assume { Resolve2.resolve _7 };
    _16 <- Vecmap_KeyRef_Type.keyref_key key;
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    _0 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 247 28 247 40] Le0.le k _16);
    goto BB6
  }
  BB6 {
    assert { [@expl:type invariant] Inv4.inv _16 };
    assume { Resolve4.resolve _16 };
    assert { [@expl:type invariant] Inv4.inv k };
    assume { Resolve4.resolve k };
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Interface
  type self
  predicate into_iter_pre (self : self)
  val into_iter_pre (self : self) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre
  type self
  predicate into_iter_pre (self : self) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 63 20 63 24] true
  val into_iter_pre (self : self) : bool
    ensures { result = into_iter_pre self }
    
end
module Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type
  type self
  type intoIter
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Interface
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
  val into_iter_post (self : self) (res : IntoIter0.intoIter) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
  val into_iter_post (self : self) (res : IntoIter0.intoIter) : bool
    ensures { result = into_iter_post self res }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Interface
  type i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub as IntoIterPost0 with
    type self = i,
    type IntoIter0.intoIter = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub as IntoIterPre0 with
    type self = i
  val into_iter (self : i) : i
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 89 0 166 1] IntoIterPre0.into_iter_pre self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs" 281 17 281 21] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 89 0 166 1] IntoIterPost0.into_iter_post self result }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs" 281 4 281 27] Inv0.inv result }
    
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Stub
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Interface
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Iter_Iterator_Completed
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module Core_Iter_Traits_Iterator_Iterator_Item_Type
  type self
  type item
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Stub
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_o : self) : bool
    ensures { result = produces self visited _o }
    
end
module CreusotContracts_Std1_Iter_Iterator_Produces
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_o : self) : bool
    ensures { result = produces self visited _o }
    
end
module Core_Iter_Range_Impl3_Next_Interface
  type a
  use prelude.Borrow
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Option_Option_Type.t_option a
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces0 with
    type self = Core_Ops_Range_Range_Type.t_range a,
    type Item0.item = a
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range a)
  val next (self : borrowed (Core_Ops_Range_Range_Type.t_range a)) : Core_Option_Option_Type.t_option a
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs" 711 17 711 21] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 95 26 98 17] match (result) with
      | Core_Option_Option_Type.C_None -> Completed0.completed self
      | Core_Option_Option_Type.C_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs" 711 4 711 35] Inv1.inv result }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Stub
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Interface
  type i
  predicate into_iter_pre (self : i)
  val into_iter_pre (self : i) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre
  type i
  predicate into_iter_pre (self : i) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 74 20 74 24] true
  val into_iter_pre (self : i) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Stub
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Interface
  type i
  predicate into_iter_post (self : i) (res : i)
  val into_iter_post (self : i) (res : i) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost
  type i
  predicate into_iter_post (self : i) (res : i) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 80 8 80 19] self = res
  val into_iter_post (self : i) (res : i) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
  val produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a }
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : () =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 30 4 30 10] ()
  val produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a }
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Stub
  type idx
  use seq.Seq
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface
  type idx
  use seq.Seq
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
  val produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c }
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans
  type idx
  use seq.Seq
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
   =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 35 4 35 10] ()
  val produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c }
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Stub
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Interface
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
  val deep_model (self : usize) : int
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Num_Impl16_DeepModel
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/num.rs" 22 16 22 35] UIntSize.to_int self
  val deep_model (self : usize) : int
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Stub
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Interface
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
  val completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed
  type idx
  use prelude.Borrow
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 14 12 14 78] Resolve0.resolve self /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start ( * self)) >= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end ( * self))
  val completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) : bool
    ensures { result = completed self }
    
end
module Vecmap_Impl1_EntryFromRef_Interface
  type k
  type v
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Vecmap_Entry_Type.t_entry k v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl6_Invariant_Stub as Invariant1 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone Vecmap_Impl1_IsValidKeyrefLg_Stub as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    axiom .
  val entry_from_ref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 4 105 80] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key_hint : Vecmap_KeyRef_Type.t_keyref k) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 100 15 100 31] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 101 15 101 48] IsValidKeyrefLg0.is_valid_keyref_lg ( * self) key_hint}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 102 15 102 60] LeLog0.le_log (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key_hint)) (DeepModel0.deep_model key)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 31 105 35] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 37 105 45] Inv1.inv key_hint}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 58 105 61] Inv2.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 103 4 103 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . Inv3.inv e -> result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 104 4 104 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . Inv4.inv e -> result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 69 105 80] Inv5.inv result }
    
end
module Vecmap_Impl1_EntryFromRef
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial19 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv22.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial18 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial17 with
    type t = usize,
    predicate Inv0.inv = Inv20.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Option_Option_Type.t_option usize
  clone TyInv_Trivial as TyInv_Trivial16 with
    type t = Core_Option_Option_Type.t_option usize,
    predicate Inv0.inv = Inv19.inv,
    axiom .
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range usize)
  clone TyInv_Trivial as TyInv_Trivial15 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range usize),
    predicate Inv0.inv = Inv18.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial14 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv14.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone Vecmap_Entry_Type_Inv as Vecmap_Entry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv10.inv,
    predicate Inv2.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv7.inv,
    axiom .
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv7.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv22.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv22.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv22.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv22.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv22.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv22.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv22.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv22.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv22.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = k,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = k,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = (k, v),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel5
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve3.resolve,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface as ProducesRefl0 with
    type idx = usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Core_Ops_Range_Range_Type.t_range usize,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv14.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel as DeepModel4 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel3 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv16.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv14.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv15.inv,
    axiom .
  clone Vecmap_Impl10_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Vecmap_Impl13_ToOwned as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel4.deep_model,
    predicate Inv1.inv = Inv2.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, int),
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv14.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv15.inv,
    predicate Inv2.inv = Inv6.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv16.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl6_Invariant as Invariant1 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv14.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv15.inv
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv14.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv15.inv,
    predicate Inv2.inv = Inv6.inv,
    predicate Inv3.inv = Inv16.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get0.get,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv1.inv = Inv16.inv,
    predicate Inv2.inv = Inv14.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = k
  clone Core_Cmp_Ord_Cmp_Interface as Cmp0 with
    type self = k,
    predicate Inv0.inv = Inv5.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv20.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv4.inv,
    type Output0.output = (k, v)
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    predicate Inv0.inv = Inv18.inv,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv1.inv = Inv19.inv
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Inv0.inv = Inv3.inv,
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv17.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl1_IsValidKeyref_Interface as IsValidKeyref0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv0.inv,
    function ToOwned0.to_owned = ToOwned0.to_owned,
    predicate IsValidKeyrefLg0.is_valid_keyref_lg = IsValidKeyrefLg0.is_valid_keyref_lg,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    predicate Inv2.inv = Inv1.inv,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    function DeepModel2.deep_model = DeepModel4.deep_model,
    predicate Inv3.inv = Inv2.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv14.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv15.inv,
    predicate Inv6.inv = Inv6.inv,
    function DeepModel3.deep_model = DeepModel0.deep_model,
    predicate Inv7.inv = Inv16.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl12_AsRef_Interface as AsRef0 with
    type k = k,
    predicate Inv0.inv = Inv12.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    predicate Inv1.inv = Inv1.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg entry_from_ref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 4 105 80] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key_hint : Vecmap_KeyRef_Type.t_keyref k) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 100 15 100 31] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 101 15 101 48] IsValidKeyrefLg0.is_valid_keyref_lg ( * self) key_hint}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 102 15 102 60] LeLog0.le_log (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key_hint)) (DeepModel0.deep_model key)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 31 105 35] Inv8.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 37 105 45] Inv2.inv key_hint}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 58 105 61] Inv7.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 103 4 103 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . Inv9.inv e -> result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 104 4 104 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . Inv10.inv e -> result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 105 69 105 80] Inv11.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_Entry_Type.t_entry k v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key_hint : Vecmap_KeyRef_Type.t_keyref k = key_hint;
  var key : k = key;
  var _9 : ();
  var _13 : bool;
  var _16 : Vecmap_KeyRef_Type.t_keyref k;
  var _17 : Vecmap_KeyRef_Type.t_keyref k;
  var min_idx : usize;
  var iter : Core_Ops_Range_Range_Type.t_range usize;
  var _25 : usize;
  var iter_old : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var produced : Ghost.ghost_ty (Seq.seq usize);
  var _35 : Core_Option_Option_Type.t_option usize;
  var _36 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _37 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var __creusot_proc_iter_elem : usize;
  var _40 : Ghost.ghost_ty (Seq.seq usize);
  var i : usize;
  var _43 : Core_Cmp_Ordering_Type.t_ordering;
  var _45 : (k, v);
  var _49 : k;
  var _53 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _63 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var i1 : usize;
  var _70 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    switch ([#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs" 218 11 218 41] true)
      | False -> goto BB8
      | True -> goto BB3
      end
  }
  BB3 {
    _17 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 106 44 106 61] AsRef0.as_ref key_hint);
    goto BB4
  }
  BB4 {
    _16 <- _17;
    assert { [@expl:type invariant] Inv0.inv _16 };
    assume { Resolve0.resolve _16 };
    _13 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 106 22 106 62] IsValidKeyref0.is_valid_keyref ( * self) _16);
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] Inv1.inv _17 };
    assume { Resolve1.resolve _17 };
    switch (not _13)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [@expl:type invariant] Inv7.inv key };
    assume { Resolve6.resolve key };
    assert { [@expl:type invariant] Inv2.inv key_hint };
    assume { Resolve2.resolve key_hint };
    assert { [@expl:type invariant] Inv8.inv self };
    assume { Resolve7.resolve self };
    absurd
  }
  BB7 {
    _9 <- ();
    goto BB9
  }
  BB8 {
    _9 <- ();
    goto BB9
  }
  BB9 {
    min_idx <- Vecmap_KeyRef_Type.keyref_min_idx key_hint;
    assert { [@expl:type invariant] Inv2.inv key_hint };
    assume { Resolve2.resolve key_hint };
    _25 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 110 26 110 38] Len0.len (Vecmap_VecMap_Type.vecmap_v ( * self)));
    goto BB10
  }
  BB10 {
    iter <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 8 109 26] IntoIter0.into_iter (Core_Ops_Range_Range_Type.C_Range min_idx _25));
    _25 <- any usize;
    goto BB11
  }
  BB11 {
    iter_old <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 8 109 26] Ghost.new iter);
    goto BB12
  }
  BB12 {
    produced <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 8 109 26] Ghost.new (Seq.empty ));
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 8 109 26] Inv3.inv iter };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 8 109 26] Produces0.produces (Ghost.inner iter_old) (Ghost.inner produced) iter };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 20 109 24] true };
    goto BB15
  }
  BB15 {
    _37 <- Borrow.borrow_mut iter;
    iter <-  ^ _37;
    _36 <- Borrow.borrow_mut ( * _37);
    _37 <- { _37 with current = ( ^ _36) };
    _35 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 8 109 26] Next0.next _36);
    _36 <- any borrowed (Core_Ops_Range_Range_Type.t_range usize);
    goto BB16
  }
  BB16 {
    assume { Resolve3.resolve _37 };
    switch (_35)
      | Core_Option_Option_Type.C_None -> goto BB17
      | Core_Option_Option_Type.C_Some _ -> goto BB18
      end
  }
  BB17 {
    i1 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 122 16 122 28] Len0.len (Vecmap_VecMap_Type.vecmap_v ( * self)));
    goto BB35
  }
  BB18 {
    goto BB20
  }
  BB19 {
    assert { [@expl:type invariant] Inv7.inv key };
    assume { Resolve6.resolve key };
    assert { [@expl:type invariant] Inv8.inv self };
    assume { Resolve7.resolve self };
    absurd
  }
  BB20 {
    __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _35;
    _40 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 109 8 109 26] Ghost.new (Seq.(++) (Ghost.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB21
  }
  BB21 {
    produced <- _40;
    _40 <- any Ghost.ghost_ty (Seq.seq usize);
    i <- __creusot_proc_iter_elem;
    _45 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 111 18 111 27] Index0.index (Vecmap_VecMap_Type.vecmap_v ( * self)) i);
    goto BB22
  }
  BB22 {
    assert { [@expl:type invariant] Inv4.inv _45 };
    assume { Resolve4.resolve _45 };
    _49 <- key;
    assert { [@expl:type invariant] Inv5.inv _49 };
    assume { Resolve5.resolve _49 };
    _43 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 111 18 111 39] Cmp0.cmp (let (a, _) = _45 in a) _49);
    goto BB23
  }
  BB23 {
    switch (_43)
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB25
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB26
      | _ -> goto BB24
      end
  }
  BB24 {
    goto BB14
  }
  BB25 {
    goto BB27
  }
  BB26 {
    goto BB30
  }
  BB27 {
    _53 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _53) };
    assume { Inv6.inv ( ^ _53) };
    goto BB28
  }
  BB28 {
    _0 <- Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry _53 key i);
    _53 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB29
  }
  BB29 {
    goto BB39
  }
  BB30 {
    switch (not ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 116 28 116 34] i >= ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 116 33 116 34] (1 : usize))))
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    assert { [@expl:type invariant] Inv7.inv key };
    assume { Resolve6.resolve key };
    assert { [@expl:type invariant] Inv8.inv self };
    assume { Resolve7.resolve self };
    absurd
  }
  BB32 {
    _63 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _63) };
    assume { Inv6.inv ( ^ _63) };
    goto BB33
  }
  BB33 {
    _0 <- Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry _63 key i);
    _63 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB34
  }
  BB34 {
    goto BB39
  }
  BB35 {
    _70 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _70) };
    assume { Inv6.inv ( ^ _70) };
    goto BB36
  }
  BB36 {
    _0 <- Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry _70 key i1);
    _70 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB37
  }
  BB37 {
    goto BB38
  }
  BB38 {
    goto BB41
  }
  BB39 {
    goto BB40
  }
  BB40 {
    goto BB41
  }
  BB41 {
    assert { [@expl:type invariant] Inv8.inv self };
    assume { Resolve7.resolve self };
    return _0
  }
  
end
module Core_Cmp_Impls_Impl10_Ge_Interface
  type a
  type b
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel1 with
    type t = b,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = b
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = a
  val ge (self : a) (other : b) : bool
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1478 15 1478 19] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1478 21 1478 26] Inv1.inv other}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/cmp.rs" 36 26 36 77] result = GeLog0.ge_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module Vecmap_Impl1_FindRandomMappingAfter_Interface
  type k
  type v
  use prelude.Int
  use seq.Seq
  use prelude.Borrow
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val find_random_mapping_after [#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 4 138 93] (self : Vecmap_VecMap_Type.t_vecmap k v) (min_key_inclusive : k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 129 15 129 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 38 138 42] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 44 138 61] Inv1.inv min_key_inclusive}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 130 4 131 66] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 132 4 133 66] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv2.inv mapping -> result = Core_Option_Option_Type.C_Some mapping /\ i >= 0 /\ i < UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 134 4 135 67] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv2.inv mapping -> result = Core_Option_Option_Type.C_Some mapping /\ i >= UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 136 4 137 61] forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv2.inv mapping -> result = Core_Option_Option_Type.C_Some mapping -> (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) (UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a))) in a) = (let (_, a) = mapping in a) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 69 138 93] Inv3.inv result }
    
end
module Vecmap_Impl1_FindRandomMappingAfter
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial17 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial16 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial15 with
    type t = k,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel3 with
    type t = (k, v),
    predicate Inv0.inv = Inv17.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial14 with
    type t = usize,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv16.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel2 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (k, v)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (k, v),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = slice (k, v),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = (k, v),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv9.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv12.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv12.inv,
    predicate Inv2.inv = Inv9.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Cmp_Impls_Impl10_Ge_Interface as Ge0 with
    type a = k,
    type b = k,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv15.inv,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    function GeLog0.ge_log = GeLog0.ge_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = (k, v),
    type i = usize,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv14.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = (k, v),
    predicate Inv2.inv = Inv3.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv3.inv = Inv6.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = slice (k, v)
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv13.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv14.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv3.inv,
    type Output0.output = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv2.inv = Inv9.inv,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv12.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg find_random_mapping_after [#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 4 138 93] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (min_key_inclusive : k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 129 15 129 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 38 138 42] Inv2.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 44 138 61] Inv1.inv min_key_inclusive}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 130 4 131 66] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 132 4 133 66] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv7.inv mapping -> result = Core_Option_Option_Type.C_Some mapping /\ i >= 0 /\ i < UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 134 4 135 67] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv7.inv mapping -> result = Core_Option_Option_Type.C_Some mapping /\ i >= UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 136 4 137 61] forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv7.inv mapping -> result = Core_Option_Option_Type.C_Some mapping -> (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) (UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a))) in a) = (let (_, a) = mapping in a) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 138 69 138 93] Inv8.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var min_key_inclusive : k = min_key_inclusive;
  var _8 : Core_Result_Result_Type.t_result usize usize;
  var _11 : k;
  var index : usize;
  var key : k;
  var value : v;
  var _16 : (k, v);
  var _17 : (k, v);
  var index1 : usize;
  var _26 : Core_Option_Option_Type.t_option (k, v);
  var _28 : slice (k, v);
  var key1 : k;
  var value1 : v;
  var _36 : bool;
  var _39 : k;
  var _40 : k;
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _11 <- min_key_inclusive;
    assert { [@expl:type invariant] Inv0.inv _11 };
    assume { Resolve0.resolve _11 };
    _8 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 139 14 139 45] FindK0.find_k self _11);
    goto BB4
  }
  BB4 {
    switch (_8)
      | Core_Result_Result_Type.C_Ok _ -> goto BB5
      | Core_Result_Result_Type.C_Err _ -> goto BB6
      end
  }
  BB5 {
    goto BB8
  }
  BB6 {
    index1 <- Core_Result_Result_Type.err_0 _8;
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve2.resolve self };
    _28 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 144 32 144 49] Deref0.deref (Vecmap_VecMap_Type.vecmap_v self));
    goto BB10
  }
  BB7 {
    absurd
  }
  BB8 {
    assert { [@expl:type invariant] Inv1.inv min_key_inclusive };
    assume { Resolve1.resolve min_key_inclusive };
    index <- Core_Result_Result_Type.ok_0 _8;
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve2.resolve self };
    _17 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 141 36 141 49] Index0.index (Vecmap_VecMap_Type.vecmap_v self) index);
    goto BB9
  }
  BB9 {
    _16 <- _17;
    assert { [@expl:type invariant] Inv3.inv _17 };
    assume { Resolve3.resolve _17 };
    key <- (let (a, _) = _16 in a);
    value <- (let (_, a) = _16 in a);
    assert { [@expl:type invariant] Inv3.inv _16 };
    assume { Resolve3.resolve _16 };
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv4.inv value };
    assume { Resolve4.resolve value };
    _0 <- Core_Option_Option_Type.C_Some (Vecmap_KeyRef_Type.C_KeyRef key index, value);
    goto BB19
  }
  BB10 {
    assert { [@expl:type invariant] Inv5.inv _28 };
    assume { Resolve5.resolve _28 };
    _26 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 144 32 144 49] Get0.get _28 index1);
    goto BB11
  }
  BB11 {
    switch (_26)
      | Core_Option_Option_Type.C_None -> goto BB12
      | Core_Option_Option_Type.C_Some _ -> goto BB13
      end
  }
  BB12 {
    assert { [@expl:type invariant] Inv6.inv _26 };
    assume { Resolve6.resolve _26 };
    assert { [@expl:type invariant] Inv1.inv min_key_inclusive };
    assume { Resolve1.resolve min_key_inclusive };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB18
  }
  BB13 {
    goto BB14
  }
  BB14 {
    key1 <- (let (a, _) = Core_Option_Option_Type.some_0 _26 in a);
    value1 <- (let (_, a) = Core_Option_Option_Type.some_0 _26 in a);
    assert { [@expl:type invariant] Inv6.inv _26 };
    assume { Resolve6.resolve _26 };
    _40 <- min_key_inclusive;
    _39 <- _40;
    assert { [@expl:type invariant] Inv0.inv _40 };
    assume { Resolve0.resolve _40 };
    _36 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 146 28 146 53] Ge0.ge key1 _39);
    goto BB15
  }
  BB15 {
    assert { [@expl:type invariant] Inv0.inv _39 };
    assume { Resolve0.resolve _39 };
    assert { [@expl:type invariant] Inv1.inv min_key_inclusive };
    assume { Resolve1.resolve min_key_inclusive };
    switch (not _36)
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assert { [@expl:type invariant] Inv4.inv value1 };
    assume { Resolve4.resolve value1 };
    assert { [@expl:type invariant] Inv0.inv key1 };
    assume { Resolve0.resolve key1 };
    absurd
  }
  BB17 {
    assert { [@expl:type invariant] Inv0.inv key1 };
    assume { Resolve0.resolve key1 };
    assert { [@expl:type invariant] Inv4.inv value1 };
    assume { Resolve4.resolve value1 };
    _0 <- Core_Option_Option_Type.C_Some (Vecmap_KeyRef_Type.C_KeyRef key1 index1, value1);
    goto BB18
  }
  BB18 {
    goto BB19
  }
  BB19 {
    goto BB20
  }
  BB20 {
    return _0
  }
  BB23 {
    assert { [@expl:type invariant] Inv1.inv min_key_inclusive };
    assume { Resolve1.resolve min_key_inclusive };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve2.resolve self };
    goto BB7
  }
  BB24 {
    assert { [@expl:type invariant] Inv6.inv _26 };
    assume { Resolve6.resolve _26 };
    assert { [@expl:type invariant] Inv1.inv min_key_inclusive };
    assume { Resolve1.resolve min_key_inclusive };
    goto BB7
  }
  
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/model.rs" 101 8 101 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl13_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = borrowed Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 132 27 132 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2685 22 2685 26] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2685 28 2685 33] Inv1.inv index}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 133 26 133 54] HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 134 26 134 57] HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 135 26 135 62] ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 136 26 136 55] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2685 4 2685 58] Inv2.inv result }
    
end
module Core_Mem_Replace_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  val replace (dest : borrowed t) (src : t) : t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs" 911 24 911 28] Inv0.inv dest}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs" 911 38 911 41] Inv1.inv src}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/mem.rs" 7 22 7 34]  ^ dest = src }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/mem.rs" 8 22 8 37] result =  * dest }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs" 911 0 911 50] Inv1.inv result }
    
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub
  type t
  type a
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Interface
  type t
  type a
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic
  type t
  type a
  use prelude.Int
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ops.rs" 19 8 19 31] Seq.get (ShallowModel0.shallow_model self) ix
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module Alloc_Vec_Impl1_Insert_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type a = a
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  val insert (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) (element : t) : ()
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1435 23 1435 27] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1435 43 1435 50] Inv1.inv element}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 95 26 95 59] Seq.length (ShallowModel0.shallow_model ( ^ self)) = Seq.length (ShallowModel1.shallow_model self) + 1 }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 96 16 96 89] forall i : int . 0 <= i /\ i < UIntSize.to_int index -> IndexLogic0.index_logic ( ^ self) i = IndexLogic0.index_logic ( * self) i }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 97 26 97 52] IndexLogic0.index_logic ( ^ self) (UIntSize.to_int index) = element }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 98 16 98 105] forall i : int . UIntSize.to_int index < i /\ i < Seq.length (ShallowModel0.shallow_model ( ^ self)) -> IndexLogic0.index_logic ( ^ self) i = IndexLogic0.index_logic ( * self) (i - 1) }
    
end
module Vecmap_Impl1_InsertInternal_Interface
  type k
  type v
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  val insert_internal [#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 4 363 63] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (idx : usize) (key : k) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 344 15 344 38] UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 28 363 32] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 46 363 49] Inv1.inv key}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 54 363 59] Inv2.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 345 14 345 55] Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) + 1 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 346 4 346 85] forall i : int . 0 <= i /\ i < UIntSize.to_int idx -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 347 14 347 48] Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) (UIntSize.to_int idx) = (key, value) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 348 4 348 105] forall i : int . UIntSize.to_int idx < i /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i - 1) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 349 4 349 80] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) = 0 -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 350 4 354 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UIntSize.to_int idx > 0 /\ UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 355 4 358 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UIntSize.to_int idx = 0 /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 359 4 362 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UIntSize.to_int idx = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    
end
module Vecmap_Impl1_InsertInternal
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = (k, v),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = v,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv7.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Alloc_Vec_Impl1_Insert_Interface as Insert0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv6.inv
  let rec cfg insert_internal [#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 4 363 63] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (idx : usize) (key : k) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 344 15 344 38] UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 28 363 32] Inv1.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 46 363 49] Inv2.inv key}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 363 54 363 59] Inv3.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 345 14 345 55] Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) + 1 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 346 4 346 85] forall i : int . 0 <= i /\ i < UIntSize.to_int idx -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 347 14 347 48] Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) (UIntSize.to_int idx) = (key, value) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 348 4 348 105] forall i : int . UIntSize.to_int idx < i /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i - 1) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 349 4 349 80] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) = 0 -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 350 4 354 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UIntSize.to_int idx > 0 /\ UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 355 4 358 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UIntSize.to_int idx = 0 /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 359 4 362 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UIntSize.to_int idx = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var idx : usize = idx;
  var key : k = key;
  var value : v = value;
  var _14 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    _14 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self));
    self <- { self with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self in Vecmap_VecMap_Type.C_VecMap ( ^ _14)) };
    assume { Inv0.inv ( ^ _14) };
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    _0 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 364 8 364 40] Insert0.insert _14 idx (key, value));
    _14 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    key <- any k;
    value <- any v;
    goto BB7
  }
  BB7 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 122 8 122 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Vecmap_Impl1_Insert_Interface
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val insert [#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 4 159 59] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) (value : v) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 156 4 156 40] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 23 159 27] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 29 159 32] Inv1.inv key}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 37 159 42] Inv2.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 156 4 156 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 157 4 158 86] exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (KeySeq0.key_seq ( ^ self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i in a) = value }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 50 159 59] Inv3.inv result }
    
end
module Vecmap_Impl1_Insert
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial14 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = usize,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Option_Option_Type.t_option v
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Core_Option_Option_Type.t_option v,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed v
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = borrowed v,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (k, v)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = borrowed (k, v),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = v,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv11.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv7.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = v
  clone Vecmap_Impl1_InsertInternal_Interface as InsertInternal0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv3.inv,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv3.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv11.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = (k, v)
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv3.inv
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv13.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv4.inv,
    type Output0.output = (k, v),
    predicate Inv3.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv11.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv2.inv = Inv7.inv,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv11.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg insert [#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 4 159 59] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) (value : v) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 156 4 156 40] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 23 159 27] Inv6.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 29 159 32] Inv1.inv key}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 37 159 42] Inv3.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 156 4 156 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 157 4 158 86] exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (KeySeq0.key_seq ( ^ self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i in a) = value }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 159 50 159 59] Inv8.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key : k = key;
  var value : v = value;
  var _7 : Core_Result_Result_Type.t_result usize usize;
  var _10 : k;
  var index : usize;
  var _13 : v;
  var _14 : borrowed v;
  var _15 : borrowed v;
  var _16 : borrowed (k, v);
  var _17 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var index1 : usize;
  var _21 : ();
  var _22 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _10 <- key;
    assert { [@expl:type invariant] Inv0.inv _10 };
    assume { Resolve0.resolve _10 };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 160 14 160 31] FindK0.find_k ( * self) _10);
    goto BB2
  }
  BB2 {
    switch (_7)
      | Core_Result_Result_Type.C_Ok _ -> goto BB3
      | Core_Result_Result_Type.C_Err _ -> goto BB4
      end
  }
  BB3 {
    goto BB6
  }
  BB4 {
    index1 <- Core_Result_Result_Type.err_0 _7;
    _22 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _22) };
    assume { Inv7.inv ( ^ _22) };
    _21 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 163 16 163 55] InsertInternal0.insert_internal _22 index1 key value);
    _22 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    value <- any v;
    goto BB10
  }
  BB5 {
    assert { [@expl:type invariant] Inv3.inv value };
    assume { Resolve5.resolve value };
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    absurd
  }
  BB6 {
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    index <- Core_Result_Result_Type.ok_0 _7;
    _17 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self));
    self <- { self with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self in Vecmap_VecMap_Type.C_VecMap ( ^ _17)) };
    assume { Inv2.inv ( ^ _17) };
    _16 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 161 53 161 66] IndexMut0.index_mut _17 index);
    _17 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB7
  }
  BB7 {
    _15 <- Borrow.borrow_mut (let (_, a) =  * _16 in a);
    _16 <- { _16 with current = (let (a, b) =  * _16 in (a,  ^ _15)) };
    assume { Inv3.inv ( ^ _15) };
    _14 <- Borrow.borrow_mut ( * _15);
    _15 <- { _15 with current = ( ^ _14) };
    assume { Inv3.inv ( ^ _14) };
    _13 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 161 30 161 76] Replace0.replace _14 value);
    _14 <- any borrowed v;
    value <- any v;
    goto BB8
  }
  BB8 {
    assert { [@expl:type invariant] Inv4.inv _16 };
    assume { Resolve2.resolve _16 };
    assert { [@expl:type invariant] Inv5.inv _15 };
    assume { Resolve3.resolve _15 };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    _0 <- Core_Option_Option_Type.C_Some _13;
    _13 <- any v;
    goto BB9
  }
  BB9 {
    goto BB11
  }
  BB10 {
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/resolve.rs" 16 8 16 60] Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module Alloc_Vec_Impl1_Remove_Interface
  type t
  type a
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use seq_ext.SeqExt
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type a = a
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val remove (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) : t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 89 27 89 44] UIntSize.to_int index < Seq.length (ShallowModel0.shallow_model self)}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1496 23 1496 27] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 90 26 90 45] result = IndexLogic0.index_logic ( * self) (UIntSize.to_int index) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 91 26 91 111] ShallowModel1.shallow_model ( ^ self) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model self) 0 (UIntSize.to_int index)) (SeqExt.subsequence (ShallowModel0.shallow_model self) (UIntSize.to_int index + 1) (Seq.length (ShallowModel0.shallow_model self))) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 92 26 92 59] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) - 1 }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1496 4 1496 47] Inv1.inv result }
    
end
module Vecmap_Impl1_Remove_Interface
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use seq_ext.SeqExt
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv5.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val remove [#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 4 181 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 171 4 171 40] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 23 181 27] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 29 181 32] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 171 4 171 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 172 4 174 30] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq ( * self)) (DeepModel0.deep_model key) /\  * self =  ^ self }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 175 4 180 17] forall v : v . Inv2.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) -> Seq.get (KeySeq0.key_seq ( * self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i in a) = v /\ ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self)) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) 0 i) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i + 1) (Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 41 181 50] Inv3.inv result }
    
end
module Vecmap_Impl1_Remove
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq_ext.SeqExt
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Option_Option_Type.t_option v
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Core_Option_Option_Type.t_option v,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = (k, v),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv9.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv,
    predicate Inv2.inv = Inv7.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve2 with
    type t1 = k,
    type t2 = v,
    predicate Resolve0.resolve = Resolve3.resolve,
    predicate Resolve1.resolve = Resolve4.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Alloc_Vec_Impl1_Remove_Interface as Remove0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv0.inv = Inv10.inv,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv9.inv
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv2.inv = Inv7.inv,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv9.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg remove [#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 4 181 50] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 171 4 171 40] IsSorted0.is_sorted ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 23 181 27] Inv2.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 29 181 32] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 171 4 171 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 172 4 174 30] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq ( * self)) (DeepModel0.deep_model key) /\  * self =  ^ self }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 175 4 180 17] forall v : v . Inv4.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) -> Seq.get (KeySeq0.key_seq ( * self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i in a) = v /\ ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self)) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) 0 i) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i + 1) (Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 181 41 181 50] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key : k = key;
  var _7 : Core_Result_Result_Type.t_result usize usize;
  var index : usize;
  var _13 : (k, v);
  var _14 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 182 14 182 30] FindK0.find_k ( * self) key);
    goto BB1
  }
  BB1 {
    switch (_7)
      | Core_Result_Result_Type.C_Ok _ -> goto BB2
      | Core_Result_Result_Type.C_Err _ -> goto BB3
      end
  }
  BB2 {
    goto BB5
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB9
  }
  BB4 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB5 {
    index <- Core_Result_Result_Type.ok_0 _7;
    _14 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self));
    self <- { self with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self in Vecmap_VecMap_Type.C_VecMap ( ^ _14)) };
    assume { Inv1.inv ( ^ _14) };
    _13 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 183 30 183 50] Remove0.remove _14 index);
    _14 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB6
  }
  BB6 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    assert { [@expl:type invariant] Inv3.inv _13 };
    assume { Resolve2.resolve _13 };
    _0 <- Core_Option_Option_Type.C_Some (let (_, a) = _13 in a);
    _13 <- (let (a, b) = _13 in (a, any v));
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Vecmap_Impl1_Get_Interface
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv5.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val get [#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 4 194 44] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 189 15 189 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 16 194 20] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 22 194 25] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 190 4 190 77] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 191 4 193 77] forall v : v . Inv2.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = v) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 34 194 44] Inv3.inv result }
    
end
module Vecmap_Impl1_Get
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = usize,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Option_Option_Type.t_option v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Core_Option_Option_Type.t_option v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = v,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv8.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    predicate Inv2.inv = Inv5.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv10.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv2.inv = Inv5.inv,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv8.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg get [#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 4 194 44] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 189 15 189 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 16 194 20] Inv1.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 22 194 25] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 190 4 190 77] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 191 4 193 77] forall v : v . Inv3.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = v) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 194 34 194 44] Inv4.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : k = key;
  var _6 : Core_Result_Result_Type.t_result usize usize;
  var index : usize;
  var _12 : v;
  var _13 : (k, v);
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    _6 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 195 14 195 30] FindK0.find_k self key);
    goto BB1
  }
  BB1 {
    switch (_6)
      | Core_Result_Result_Type.C_Ok _ -> goto BB2
      | Core_Result_Result_Type.C_Err _ -> goto BB3
      end
  }
  BB2 {
    goto BB5
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB7
  }
  BB4 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB5 {
    index <- Core_Result_Result_Type.ok_0 _6;
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _13 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 196 31 196 44] Index0.index (Vecmap_VecMap_Type.vecmap_v self) index);
    goto BB6
  }
  BB6 {
    _12 <- (let (_, a) = _13 in a);
    assert { [@expl:type invariant] Inv2.inv _13 };
    assume { Resolve2.resolve _13 };
    assert { [@expl:type invariant] Inv3.inv _12 };
    assume { Resolve3.resolve _12 };
    _0 <- Core_Option_Option_Type.C_Some _12;
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Core_Result_Impl0_IsOk_Interface
  type t
  type e
  use prelude.Borrow
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Result_Result_Type.t_result t e
  val is_ok (self : Core_Result_Result_Type.t_result t e) : bool
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs" 538 24 538 28] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/result.rs" 22 26 22 63] result = (exists t : t . Inv1.inv t /\ self = Core_Result_Result_Type.C_Ok t) }
    
end
module Vecmap_Impl1_ContainsKey_Interface
  type k
  type v
  use prelude.Borrow
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val contains_key [#"/mnt/data/projects/creusot/examples/vecmap.rs" 204 4 204 47] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : bool
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 202 15 202 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 204 25 204 29] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 204 31 204 34] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 203 14 203 65] result = Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    
end
module Vecmap_Impl1_ContainsKey
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = usize,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Result_Result_Type.t_result usize usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv2.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Result_Impl0_IsOk_Interface as IsOk0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv2.inv = Inv2.inv,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv5.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg contains_key [#"/mnt/data/projects/creusot/examples/vecmap.rs" 204 4 204 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : bool
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 202 15 202 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 204 25 204 29] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 204 31 204 34] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 203 14 203 65] result = Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : k = key;
  var _6 : Core_Result_Result_Type.t_result usize usize;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    _6 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 205 8 205 24] FindK0.find_k self key);
    goto BB1
  }
  BB1 {
    _0 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 205 8 205 32] IsOk0.is_ok _6);
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Core_Cmp_PartialOrd_Gt_Interface
  type self
  type rhs
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel1 with
    type t = rhs,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = rhs
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  val gt (self : self) (other : rhs) : bool
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1100 11 1100 15] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1100 17 1100 22] Inv1.inv other}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/cmp.rs" 33 26 33 76] result = GtLog0.gt_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module Vecmap_Impl1_NextMapping_Interface
  type k
  type v
  use prelude.Int
  use seq.Seq
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val next_mapping [#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 4 222 75] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 210 15 210 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 25 222 29] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 31 222 34] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 211 4 213 57] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 214 4 221 57] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv2.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)) /\ GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = (let (_, a) = entry in a) /\ (forall j : int . j >= 0 /\ j < i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a))) /\ LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 51 222 75] Inv3.inv result }
    
end
module Vecmap_Impl1_NextMapping
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial19 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv19.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial18 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial17 with
    type t = usize,
    predicate Inv0.inv = Inv17.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Core_Option_Option_Type.t_option usize
  clone TyInv_Trivial as TyInv_Trivial16 with
    type t = Core_Option_Option_Type.t_option usize,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range usize)
  clone TyInv_Trivial as TyInv_Trivial15 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range usize),
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial14 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = v,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = k,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel4
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve1.resolve,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv19.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv19.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv19.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv19.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv19.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv19.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface as ProducesRefl0 with
    type idx = usize,
    predicate Inv0.inv = Inv1.inv,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Core_Ops_Range_Range_Type.t_range usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel3 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Vecmap_Impl10_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv12.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    predicate Inv1.inv = Inv13.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv11.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv12.inv,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    predicate Inv3.inv = Inv13.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get0.get,
    predicate Inv0.inv = Inv12.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv1.inv = Inv13.inv,
    predicate Inv2.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv11.inv,
    axiom .
  clone Vecmap_Impl13_ToOwned as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv3.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    predicate Inv1.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Core_Cmp_PartialOrd_Gt_Interface as Gt0 with
    type self = k,
    type rhs = k,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv5.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv17.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v)
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    predicate Inv0.inv = Inv15.inv,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv1.inv = Inv16.inv
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Inv0.inv = Inv1.inv,
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv14.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Vecmap_Impl1_IsValidKeyref_Interface as IsValidKeyref0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv0.inv,
    function ToOwned0.to_owned = ToOwned0.to_owned,
    predicate IsValidKeyrefLg0.is_valid_keyref_lg = IsValidKeyrefLg0.is_valid_keyref_lg,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    predicate Inv2.inv = Inv3.inv,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    function DeepModel2.deep_model = DeepModel2.deep_model,
    predicate Inv3.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv4.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv11.inv,
    predicate Inv6.inv = Inv12.inv,
    function DeepModel3.deep_model = DeepModel3.deep_model,
    predicate Inv7.inv = Inv13.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg next_mapping [#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 4 222 75] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 210 15 210 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 25 222 29] Inv4.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 31 222 34] Inv3.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 211 4 213 57] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 214 4 221 57] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv7.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)) /\ GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = (let (_, a) = entry in a) /\ (forall j : int . j >= 0 /\ j < i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a))) /\ LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 222 51 222 75] Inv8.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : Vecmap_KeyRef_Type.t_keyref k = key;
  var from : usize;
  var _7 : bool;
  var _10 : Vecmap_KeyRef_Type.t_keyref k;
  var iter : Core_Ops_Range_Range_Type.t_range usize;
  var _15 : usize;
  var iter_old : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var produced : Ghost.ghost_ty (Seq.seq usize);
  var _25 : Core_Option_Option_Type.t_option usize;
  var _26 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _27 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var __creusot_proc_iter_elem : usize;
  var _30 : Ghost.ghost_ty (Seq.seq usize);
  var idx : usize;
  var _33 : bool;
  var _35 : (k, v);
  var key1 : k;
  var value : v;
  var _42 : (k, v);
  var _43 : (k, v);
  {
    goto BB0
  }
  BB0 {
    _10 <- key;
    assert { [@expl:type invariant] Inv0.inv _10 };
    assume { Resolve0.resolve _10 };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 223 22 223 48] IsValidKeyref0.is_valid_keyref self _10);
    goto BB1
  }
  BB1 {
    switch (_7)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    from <- Vecmap_KeyRef_Type.keyref_min_idx key;
    goto BB4
  }
  BB3 {
    from <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 226 12 226 13] (0 : usize));
    goto BB4
  }
  BB4 {
    _15 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 231 25 231 37] Len0.len (Vecmap_VecMap_Type.vecmap_v self));
    goto BB5
  }
  BB5 {
    iter <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] IntoIter0.into_iter (Core_Ops_Range_Range_Type.C_Range from _15));
    _15 <- any usize;
    goto BB6
  }
  BB6 {
    iter_old <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] Ghost.new iter);
    goto BB7
  }
  BB7 {
    produced <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] Ghost.new (Seq.empty ));
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] Inv1.inv iter };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] Produces0.produces (Ghost.inner iter_old) (Ghost.inner produced) iter };
    invariant { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] forall j : int . j >= 0 /\ j < Seq.length (Ghost.inner produced) + UIntSize.to_int from -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) };
    goto BB10
  }
  BB10 {
    _27 <- Borrow.borrow_mut iter;
    iter <-  ^ _27;
    _26 <- Borrow.borrow_mut ( * _27);
    _27 <- { _27 with current = ( ^ _26) };
    _25 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] Next0.next _26);
    _26 <- any borrowed (Core_Ops_Range_Range_Type.t_range usize);
    goto BB11
  }
  BB11 {
    assume { Resolve1.resolve _27 };
    switch (_25)
      | Core_Option_Option_Type.C_None -> goto BB12
      | Core_Option_Option_Type.C_Some _ -> goto BB13
      end
  }
  BB12 {
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv4.inv self };
    assume { Resolve4.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB22
  }
  BB13 {
    goto BB15
  }
  BB14 {
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv4.inv self };
    assume { Resolve4.resolve self };
    absurd
  }
  BB15 {
    __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _25;
    _30 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 229 8 230 63] Ghost.new (Seq.(++) (Ghost.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB16
  }
  BB16 {
    produced <- _30;
    _30 <- any Ghost.ghost_ty (Seq.seq usize);
    idx <- __creusot_proc_iter_elem;
    _35 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 232 15 232 26] Index0.index (Vecmap_VecMap_Type.vecmap_v self) idx);
    goto BB17
  }
  BB17 {
    assert { [@expl:type invariant] Inv2.inv _35 };
    assume { Resolve2.resolve _35 };
    _33 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 232 15 232 39] Gt0.gt (let (a, _) = _35 in a) (Vecmap_KeyRef_Type.keyref_key key));
    goto BB18
  }
  BB18 {
    switch (_33)
      | False -> goto BB21
      | True -> goto BB19
      end
  }
  BB19 {
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv4.inv self };
    assume { Resolve4.resolve self };
    _43 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 233 36 233 47] Index0.index (Vecmap_VecMap_Type.vecmap_v self) idx);
    goto BB20
  }
  BB20 {
    _42 <- _43;
    assert { [@expl:type invariant] Inv2.inv _43 };
    assume { Resolve2.resolve _43 };
    key1 <- (let (a, _) = _42 in a);
    value <- (let (_, a) = _42 in a);
    assert { [@expl:type invariant] Inv2.inv _42 };
    assume { Resolve2.resolve _42 };
    assert { [@expl:type invariant] Inv5.inv key1 };
    assume { Resolve5.resolve key1 };
    assert { [@expl:type invariant] Inv6.inv value };
    assume { Resolve6.resolve value };
    _0 <- Core_Option_Option_Type.C_Some (Vecmap_KeyRef_Type.C_KeyRef key1 idx, value);
    goto BB22
  }
  BB21 {
    goto BB9
  }
  BB22 {
    return _0
  }
  
end
module CreusotContracts_Logic_Ops_Impl2_IndexLogic_Stub
  type t
  use prelude.Slice
  use prelude.Int
  function index_logic [@inline:trivial] (self : slice t) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl2_IndexLogic_Interface
  type t
  use prelude.Slice
  use prelude.Int
  function index_logic [@inline:trivial] (self : slice t) (ix : int) : t
  val index_logic [@inline:trivial] (self : slice t) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl2_IndexLogic
  type t
  use prelude.Slice
  use prelude.Int
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  function index_logic [@inline:trivial] (self : slice t) (ix : int) : t =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ops.rs" 41 8 41 31] Seq.get (ShallowModel0.shallow_model self) ix
  val index_logic [@inline:trivial] (self : slice t) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module Core_Slice_Impl0_First_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Option_Option_Type.t_option t
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic_Stub as IndexLogic0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val first (self : slice t) : Core_Option_Option_Type.t_option t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 176 24 176 28] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 291 8 291 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 292 8 292 69] forall x : t . Inv1.inv x -> result = Core_Option_Option_Type.C_Some x -> IndexLogic0.index_logic self 0 = x }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 176 4 176 43] Inv2.inv result }
    
end
module Vecmap_Impl1_MinEntry_Interface
  type k
  type v
  use seq.Seq
  use prelude.Borrow
  use prelude.UIntSize
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val min_entry [#"/mnt/data/projects/creusot/examples/vecmap.rs" 273 4 273 55] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 266 15 266 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 273 22 273 26] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 267 4 267 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 268 4 268 101] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv1.inv entry -> result = Core_Option_Option_Type.C_Some entry -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) 0 = (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a), let (_, a) = entry in a) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 269 4 269 80] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv1.inv entry -> result = Core_Option_Option_Type.C_Some entry -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = entry in a)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 270 4 272 6] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv1.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 273 31 273 55] Inv2.inv result }
    
end
module Vecmap_Impl1_MinEntry
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial14 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = (k, v),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel3 with
    type t = (k, v),
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic as IndexLogic0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = slice (k, v),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv11.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv10.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    predicate Inv2.inv = Inv11.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_First_Interface as First0 with
    type t = (k, v),
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv8.inv,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv2.inv = Inv2.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = slice (k, v)
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    predicate Inv1.inv = Inv1.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg min_entry [#"/mnt/data/projects/creusot/examples/vecmap.rs" 273 4 273 55] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 266 15 266 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 273 22 273 26] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 267 4 267 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 268 4 268 101] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv5.inv entry -> result = Core_Option_Option_Type.C_Some entry -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) 0 = (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a), let (_, a) = entry in a) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 269 4 269 80] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv5.inv entry -> result = Core_Option_Option_Type.C_Some entry -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = entry in a)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 270 4 272 6] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv5.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)))) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 273 31 273 55] Inv6.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var _7 : Core_Option_Option_Type.t_option (k, v);
  var _9 : slice (k, v);
  var key : k;
  var value : v;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _9 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 274 14 274 28] Deref0.deref (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv _9 };
    assume { Resolve1.resolve _9 };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 274 14 274 28] First0.first _9);
    goto BB2
  }
  BB2 {
    switch (_7)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv _7 };
    assume { Resolve2.resolve _7 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB7
  }
  BB4 {
    goto BB6
  }
  BB5 {
    assert { [@expl:type invariant] Inv2.inv _7 };
    assume { Resolve2.resolve _7 };
    absurd
  }
  BB6 {
    key <- (let (a, _) = Core_Option_Option_Type.some_0 _7 in a);
    value <- (let (_, a) = Core_Option_Option_Type.some_0 _7 in a);
    assert { [@expl:type invariant] Inv2.inv _7 };
    assume { Resolve2.resolve _7 };
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv4.inv value };
    assume { Resolve4.resolve value };
    _0 <- Core_Option_Option_Type.C_Some (Vecmap_KeyRef_Type.C_KeyRef key ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 275 63 275 64] (0 : usize)), value);
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Core_Slice_Impl0_Last_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Option_Option_Type.t_option t
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic_Stub as IndexLogic0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val last (self : slice t) : Core_Option_Option_Type.t_option t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 299 23 299 27] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 287 8 287 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 288 8 288 83] forall x : t . Inv1.inv x -> result = Core_Option_Option_Type.C_Some x -> IndexLogic0.index_logic self (Seq.length (ShallowModel0.shallow_model self) - 1) = x }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 299 4 299 42] Inv2.inv result }
    
end
module Vecmap_Impl1_MaxKey_Interface
  type k
  type v
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Option_Option_Type.t_option k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val max_key [#"/mnt/data/projects/creusot/examples/vecmap.rs" 287 4 287 39] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 281 15 281 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 287 20 287 24] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 282 4 282 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 283 4 286 6] forall k : k . Inv1.inv k -> result = Core_Option_Option_Type.C_Some k -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model k)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 287 29 287 39] Inv2.inv result }
    
end
module Vecmap_Impl1_MaxKey
  type k
  type v
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel3 with
    type t = (k, v),
    predicate Inv0.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Option_Option_Type.t_option k
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Core_Option_Option_Type.t_option k,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = k,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = (k, v)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = (k, v),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic as IndexLogic0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate Inv0.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = slice (k, v)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = slice (k, v),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv9.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv1.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv8.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    predicate Inv2.inv = Inv9.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv3.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_Last_Interface as Last0 with
    type t = (k, v),
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv3.inv,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv2.inv = Inv2.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = slice (k, v)
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    predicate Inv1.inv = Inv1.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg max_key [#"/mnt/data/projects/creusot/examples/vecmap.rs" 287 4 287 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 281 15 281 31] IsSorted0.is_sorted self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 287 20 287 24] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 282 4 282 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 283 4 286 6] forall k : k . Inv4.inv k -> result = Core_Option_Option_Type.C_Some k -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model k)) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 287 29 287 39] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option k;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var _5 : Core_Option_Option_Type.t_option (k, v);
  var _7 : slice (k, v);
  var e : (k, v);
  var _12 : k;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 288 14 288 27] Deref0.deref (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv _7 };
    assume { Resolve1.resolve _7 };
    _5 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 288 14 288 27] Last0.last _7);
    goto BB2
  }
  BB2 {
    switch (_5)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv _5 };
    assume { Resolve2.resolve _5 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB7
  }
  BB4 {
    goto BB6
  }
  BB5 {
    assert { [@expl:type invariant] Inv2.inv _5 };
    assume { Resolve2.resolve _5 };
    absurd
  }
  BB6 {
    e <- Core_Option_Option_Type.some_0 _5;
    assert { [@expl:type invariant] Inv2.inv _5 };
    assume { Resolve2.resolve _5 };
    _12 <- (let (a, _) = e in a);
    assert { [@expl:type invariant] Inv3.inv e };
    assume { Resolve3.resolve e };
    assert { [@expl:type invariant] Inv4.inv _12 };
    assume { Resolve4.resolve _12 };
    _0 <- Core_Option_Option_Type.C_Some _12;
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Alloc_Vec_Impl10_Clone_Interface
  type t
  type a
  use prelude.Borrow
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  val clone' (self : Alloc_Vec_Vec_Type.t_vec t a) : Alloc_Vec_Vec_Type.t_vec t a
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2625 14 2625 18] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2625 4 2625 27] Inv1.inv result }
    
end
module Vecmap_Impl2_Clone_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val clone' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 370 4 370 27] (self : Vecmap_VecMap_Type.t_vecmap k v) : Vecmap_VecMap_Type.t_vecmap k v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 370 14 370 18] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 369 14 369 29] result = self }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 370 23 370 27] Inv1.inv result }
    
end
module Vecmap_Impl2_Clone
  type k
  type v
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Alloc_Vec_Impl10_Clone_Interface as Clone0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg clone' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 370 4 370 27] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) : Vecmap_VecMap_Type.t_vecmap k v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 370 14 370 18] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 369 14 369 29] result = self }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 370 23 370 27] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_VecMap_Type.t_vecmap k v;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var _3 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _3 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 371 20 371 34] Clone0.clone' (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_VecMap_Type.C_VecMap _3;
    _3 <- any Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl4_IsDefault_Stub
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_default [#"/mnt/data/projects/creusot/examples/vecmap.rs" 388 4 388 31] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
end
module Vecmap_Impl4_IsDefault_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_default [#"/mnt/data/projects/creusot/examples/vecmap.rs" 388 4 388 31] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
  val is_default [#"/mnt/data/projects/creusot/examples/vecmap.rs" 388 4 388 31] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = is_default self }
    
end
module Vecmap_Impl4_IsDefault
  type k
  type v
  use seq.Seq
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_default [#"/mnt/data/projects/creusot/examples/vecmap.rs" 388 4 388 31] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 389 20 389 40] Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0
  val is_default [#"/mnt/data/projects/creusot/examples/vecmap.rs" 388 4 388 31] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = is_default self }
    
end
module Vecmap_Impl3_Default_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl4_IsDefault_Stub as IsDefault0 with
    type k = k,
    type v = v
  val default [#"/mnt/data/projects/creusot/examples/vecmap.rs" 377 4 377 24] (_1 : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 376 14 376 33] IsDefault0.is_default result }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 377 20 377 24] Inv0.inv result }
    
end
module Vecmap_Impl3_Default
  type k
  type v
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone Vecmap_Impl4_IsDefault as IsDefault0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv
  let rec cfg default [#"/mnt/data/projects/creusot/examples/vecmap.rs" 377 4 377 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 376 14 376 33] IsDefault0.is_default result }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 377 20 377 24] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_VecMap_Type.t_vecmap k v;
  var _2 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    _2 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 378 18 378 28] New0.new ());
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_VecMap_Type.C_VecMap _2;
    _2 <- any Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module TyInv_Borrow_Shared
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_borrow_shared [@rewrite] : forall self : t . Inv0.inv self = Inv1.inv self
end
module Vecmap_Impl5_Keyref_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_Entry_Type.t_entry k v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  val keyref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 434 4 434 38] (self : Vecmap_Entry_Type.t_entry k v) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 430 15 433 5] match (self) with
      | Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry map _ _) -> IsSorted0.is_sorted ( * map)
      | Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry map _ _) -> IsSorted0.is_sorted ( * map)
      end}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 434 19 434 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 434 28 434 38] Inv1.inv result }
    
end
module Vecmap_Impl5_Keyref
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = k,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone Vecmap_Entry_Type_Inv as Vecmap_Entry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv9.inv,
    predicate Inv2.inv = Inv10.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_Entry_Type.t_entry k v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv5.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_Entry_Type.t_entry k v
  let rec cfg keyref [#"/mnt/data/projects/creusot/examples/vecmap.rs" 434 4 434 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_Entry_Type.t_entry k v) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 430 15 433 5] match (self) with
      | Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry map _ _) -> IsSorted0.is_sorted ( * map)
      | Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry map _ _) -> IsSorted0.is_sorted ( * map)
      end}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 434 19 434 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 434 28 434 38] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_Entry_Type.t_entry k v = self;
  var key : k;
  var index : usize;
  var key1 : k;
  var index1 : usize;
  {
    goto BB0
  }
  BB0 {
    switch (self)
      | Vecmap_Entry_Type.C_Vacant _ -> goto BB1
      | Vecmap_Entry_Type.C_Occupied _ -> goto BB2
      end
  }
  BB1 {
    goto BB4
  }
  BB2 {
    key1 <- Vecmap_OccupiedEntry_Type.occupiedentry_key (Vecmap_Entry_Type.occupied_0 self);
    index1 <- Vecmap_OccupiedEntry_Type.occupiedentry_index (Vecmap_Entry_Type.occupied_0 self);
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv key1 };
    assume { Resolve1.resolve key1 };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef key1 index1;
    goto BB5
  }
  BB3 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    absurd
  }
  BB4 {
    key <- Vecmap_VacantEntry_Type.vacantentry_key (Vecmap_Entry_Type.vacant_0 self);
    index <- Vecmap_VacantEntry_Type.vacantentry_index (Vecmap_Entry_Type.vacant_0 self);
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef key index;
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Vecmap_Impl15_Resolve_Stub
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"/mnt/data/projects/creusot/examples/vecmap.rs" 449 4 449 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
end
module Vecmap_Impl15_Resolve_Interface
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"/mnt/data/projects/creusot/examples/vecmap.rs" 449 4 449 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
  val resolve [#"/mnt/data/projects/creusot/examples/vecmap.rs" 449 4 449 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = resolve self }
    
end
module Vecmap_Impl15_Resolve
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"/mnt/data/projects/creusot/examples/vecmap.rs" 449 4 449 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
   =
    [#"/mnt/data/projects/creusot/examples/vecmap.rs" 447 4 447 16] Resolve0.resolve (Vecmap_VacantEntry_Type.vacantentry_map self) /\ Resolve1.resolve (Vecmap_VacantEntry_Type.vacantentry_key self)
  val resolve [#"/mnt/data/projects/creusot/examples/vecmap.rs" 449 4 449 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = resolve self }
    
end
module Vecmap_Impl7_Insert_Interface
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv5.inv,
    axiom .
  clone Vecmap_Impl6_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  val insert [#"/mnt/data/projects/creusot/examples/vecmap.rs" 480 4 480 33] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 474 15 474 31] Invariant0.invariant' self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 475 4 476 62] forall i : int . i >= 0 /\ i < UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 477 4 478 62] forall i : int . i >= UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self))) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 480 18 480 22] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 480 24 480 29] Inv1.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 479 14 479 37] IsSorted0.is_sorted ( ^ Vecmap_VacantEntry_Type.vacantentry_map self) }
    
end
module Vecmap_Impl7_Insert
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = k,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv6.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv0.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl6_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv
  clone Vecmap_Impl15_Resolve as Resolve0 with
    type k = k,
    type v = v,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Vecmap_Impl1_InsertInternal_Interface as InsertInternal0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv2.inv,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv3.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg insert [#"/mnt/data/projects/creusot/examples/vecmap.rs" 480 4 480 33] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 474 15 474 31] Invariant0.invariant' self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 475 4 476 62] forall i : int . i >= 0 /\ i < UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 477 4 478 62] forall i : int . i >= UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self))) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 480 18 480 22] Inv1.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 480 24 480 29] Inv2.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 479 14 479 37] IsSorted0.is_sorted ( ^ Vecmap_VacantEntry_Type.vacantentry_map self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : Vecmap_VacantEntry_Type.t_vacantentry k v = self;
  var value : v = value;
  var _7 : ();
  var _8 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _8 <- Borrow.borrow_mut ( * Vecmap_VacantEntry_Type.vacantentry_map self);
    self <- (let Vecmap_VacantEntry_Type.C_VacantEntry a b c = self in Vecmap_VacantEntry_Type.C_VacantEntry ({ (Vecmap_VacantEntry_Type.vacantentry_map self) with current = ( ^ _8) }) b c);
    assume { Inv0.inv ( ^ _8) };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 481 8 481 61] InsertInternal0.insert_internal _8 (Vecmap_VacantEntry_Type.vacantentry_index self) (Vecmap_VacantEntry_Type.vacantentry_key self) value);
    _8 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    self <- (let Vecmap_VacantEntry_Type.C_VacantEntry a b c = self in Vecmap_VacantEntry_Type.C_VacantEntry a (any k) c);
    value <- any v;
    goto BB4
  }
  BB4 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:assertion] [#"/mnt/data/projects/creusot/examples/vecmap.rs" 482 22 482 38] Invariant0.invariant' self };
    goto BB5
  }
  BB5 {
    _0 <- ();
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module TyInv_Borrow
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  axiom inv_borrow [@rewrite] : forall self : borrowed t . Inv0.inv self = (Inv1.inv ( * self) /\ Inv1.inv ( ^ self))
end
module Vecmap_Impl9_Replace_Interface
  type k
  type v
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  val replace [#"/mnt/data/projects/creusot/examples/vecmap.rs" 510 4 510 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 508 4 508 40] Invariant0.invariant' ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 510 24 510 28] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 510 30 510 35] Inv1.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 508 4 508 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 509 14 509 54] (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( ^ self)))) (UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self))) in a) = value }
    
end
module Vecmap_Impl9_Replace
  type k
  type v
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = k,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv10.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = usize,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv6.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv7.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv7.inv,
    predicate Inv3.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = v
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v),
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv6.inv
  let rec cfg replace [#"/mnt/data/projects/creusot/examples/vecmap.rs" 510 4 510 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 508 4 508 40] Invariant0.invariant' ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 510 24 510 28] Inv3.inv self}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 510 30 510 35] Inv1.inv value}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 508 4 508 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 509 14 509 54] (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( ^ self)))) (UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self))) in a) = value }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v) = self;
  var value : v = value;
  var _7 : borrowed (k, v);
  var _8 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _8 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)));
    self <- { self with current = (let Vecmap_OccupiedEntry_Type.C_OccupiedEntry a b c =  * self in Vecmap_OccupiedEntry_Type.C_OccupiedEntry ({ (Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)) with current = (let Vecmap_VecMap_Type.C_VecMap a =  * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self) in Vecmap_VecMap_Type.C_VecMap ( ^ _8)) }) b c) };
    assume { Inv0.inv ( ^ _8) };
    _7 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 511 8 511 30] IndexMut0.index_mut _8 (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self)));
    _8 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _7 <- { _7 with current = (let (a, b) =  * _7 in (a, value)) };
    value <- any v;
    assert { [@expl:type invariant] Inv1.inv (let (_, a) =  * _7 in a) };
    assume { Resolve0.resolve (let (_, a) =  * _7 in a) };
    assert { [@expl:type invariant] Inv2.inv _7 };
    assume { Resolve1.resolve _7 };
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve2.resolve self };
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Vecmap_Impl9_GetMut_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = borrowed v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  val get_mut [#"/mnt/data/projects/creusot/examples/vecmap.rs" 516 4 516 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) : borrowed v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 515 4 515 40] Invariant0.invariant' ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 516 24 516 28] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 515 4 515 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 516 33 516 39] Inv1.inv result }
    
end
module Vecmap_Impl9_GetMut
  type k
  type v
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = k,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv12.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Seq.seq DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Seq.seq DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv8.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv3.inv = Inv7.inv,
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv3.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed v
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed v,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    predicate Inv3.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = (k, v)
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v),
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv7.inv
  let rec cfg get_mut [#"/mnt/data/projects/creusot/examples/vecmap.rs" 516 4 516 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) : borrowed v
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 515 4 515 40] Invariant0.invariant' ( * self)}
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 516 24 516 28] Inv4.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 515 4 515 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 516 33 516 39] Inv3.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed v;
  var self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v) = self;
  var _2 : borrowed v;
  var _5 : borrowed v;
  var _6 : borrowed (k, v);
  var _7 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    _7 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)));
    self <- { self with current = (let Vecmap_OccupiedEntry_Type.C_OccupiedEntry a b c =  * self in Vecmap_OccupiedEntry_Type.C_OccupiedEntry ({ (Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)) with current = (let Vecmap_VecMap_Type.C_VecMap a =  * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self) in Vecmap_VecMap_Type.C_VecMap ( ^ _7)) }) b c) };
    assume { Inv0.inv ( ^ _7) };
    _6 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 517 13 517 35] IndexMut0.index_mut _7 (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self)));
    _7 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB1
  }
  BB1 {
    _5 <- Borrow.borrow_mut (let (_, a) =  * _6 in a);
    _6 <- { _6 with current = (let (a, b) =  * _6 in (a,  ^ _5)) };
    assume { Inv1.inv ( ^ _5) };
    _2 <- Borrow.borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _2) };
    assume { Inv1.inv ( ^ _2) };
    _0 <- Borrow.borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Inv1.inv ( ^ _0) };
    assert { [@expl:type invariant] Inv2.inv _6 };
    assume { Resolve0.resolve _6 };
    assert { [@expl:type invariant] Inv3.inv _5 };
    assume { Resolve1.resolve _5 };
    assert { [@expl:type invariant] Inv3.inv _2 };
    assume { Resolve1.resolve _2 };
    assert { [@expl:type invariant] Inv4.inv self };
    assume { Resolve2.resolve self };
    return _0
  }
  
end
module Core_Clone_Clone_Clone_Interface
  type self
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  val clone' (self : self) : self
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs" 120 14 120 18] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs" 120 4 120 28] Inv1.inv result }
    
end
module Core_Clone_Impls_Impl5_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  val clone' (self : usize) : usize
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    
end
module Vecmap_Impl17_Clone_Interface
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  val clone' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] result = self }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] Inv1.inv result }
    
end
module Vecmap_Impl17_Clone
  type k
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone1
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv3.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg clone' [#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] Inv1.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] result = self }
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_KeyRef_Type.t_keyref k = self;
  var _3 : k;
  var _5 : k;
  var _6 : usize;
  var _8 : usize;
  {
    goto BB0
  }
  BB0 {
    _5 <- Vecmap_KeyRef_Type.keyref_key self;
    assert { [@expl:type invariant] Inv0.inv _5 };
    assume { Resolve0.resolve _5 };
    _3 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 526 4 526 14] Clone0.clone' _5);
    goto BB1
  }
  BB1 {
    _8 <- Vecmap_KeyRef_Type.keyref_min_idx self;
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _6 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 527 4 529 18] Clone1.clone' _8);
    goto BB2
  }
  BB2 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _3 _6;
    _3 <- any k;
    _6 <- any usize;
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Vecmap_Impl11_Cloned_Interface
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  val cloned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 544 4 544 36] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 544 18 544 22] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 544 27 544 36] Inv1.inv result }
    
end
module Vecmap_Impl11_Cloned
  type k
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg cloned [#"/mnt/data/projects/creusot/examples/vecmap.rs" 544 4 544 36] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 544 18 544 22] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 544 27 544 36] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_KeyRef_Type.t_keyref k = self;
  var _3 : k;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _3 <- ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 545 45 545 61] Clone0.clone' (Vecmap_KeyRef_Type.keyref_key self));
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _3 (Vecmap_KeyRef_Type.keyref_min_idx self);
    _3 <- any k;
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl14_From_Interface
  type k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  val from [#"/mnt/data/projects/creusot/examples/vecmap.rs" 566 4 566 27] (key : k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 566 12 566 15] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 566 23 566 27] Inv1.inv result }
    
end
module Vecmap_Impl14_From
  type k
  use prelude.Int
  use prelude.UIntSize
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  let rec cfg from [#"/mnt/data/projects/creusot/examples/vecmap.rs" 566 4 566 27] [@cfg:stackify] [@cfg:subregion_analysis] (key : k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/examples/vecmap.rs" 566 12 566 15] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/examples/vecmap.rs" 566 23 566 27] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var key : k = key;
  {
    goto BB0
  }
  BB0 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef key ([#"/mnt/data/projects/creusot/examples/vecmap.rs" 567 29 567 30] (0 : usize));
    key <- any k;
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl2
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  goal clone'_refn : [#"/mnt/data/projects/creusot/examples/vecmap.rs" 370 4 370 27] forall self : Vecmap_VecMap_Type.t_vecmap k v . Inv0.inv self -> Inv0.inv self /\ (forall result : Vecmap_VecMap_Type.t_vecmap k v . Inv1.inv result /\ result = self -> Inv1.inv result /\ result = self)
end
module Vecmap_Impl17
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  goal clone'_refn : [#"/mnt/data/projects/creusot/examples/vecmap.rs" 524 15 524 20] forall self : Vecmap_KeyRef_Type.t_keyref k . Inv0.inv self -> Inv0.inv self /\ (forall result : Vecmap_KeyRef_Type.t_keyref k . Inv1.inv result /\ result = self -> Inv1.inv result /\ result = self)
end
module Vecmap_Impl3
  type k
  type v
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Seq.seq (k, v)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Seq.seq (k, v),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Vecmap_Impl4_IsDefault as IsDefault0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv
  goal default_refn : [#"/mnt/data/projects/creusot/examples/vecmap.rs" 377 4 377 24] forall _1' : () . forall result : Vecmap_VecMap_Type.t_vecmap k v . Inv0.inv result /\ IsDefault0.is_default result -> Inv0.inv result /\ IsDefault0.is_default result
end
module Vecmap_Impl4
  type k
  type v
end
module Vecmap_Impl15
  type k
  type v
end
module Vecmap_Impl6
  type k
  type v
end
module Vecmap_Impl8
  type k
  type v
end
module Vecmap_Impl16
  type k
end
module Vecmap_Impl10
  type k
end
module Vecmap_Impl14
  type k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  goal from_refn : [#"/mnt/data/projects/creusot/examples/vecmap.rs" 566 4 566 27] forall value : k . Inv0.inv value -> Inv0.inv value /\ (forall result : Vecmap_KeyRef_Type.t_keyref k . Inv1.inv result -> Inv1.inv result)
end
