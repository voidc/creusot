
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
  let function unique_pointer (self : t_unique 't) : Core_Ptr_NonNull_NonNull_Type.t_nonnull 't
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Unique a _ -> a
      end
  let function unique__marker (self : t_unique 't) : Core_Marker_PhantomData_Type.t_phantomdata 't
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Unique _ a -> a
      end
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
  let function rawvec_ptr (self : t_rawvec 't 'a) : Core_Ptr_Unique_Unique_Type.t_unique 't
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RawVec a _ _ -> a
      end
  let function rawvec_alloc (self : t_rawvec 't 'a) : 'a = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RawVec _ _ a -> a
      end
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
  let function vec_buf (self : t_vec 't 'a) : Alloc_RawVec_RawVec_Type.t_rawvec 't 'a = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Vec a _ -> a
      end
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Vecmap_VecMap_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_vecmap 'k 'v =
    | C_VecMap (Alloc_Vec_Vec_Type.t_vec ('k, 'v) (Alloc_Alloc_Global_Type.t_global))
    
  let function vecmap_v (self : t_vecmap 'k 'v) : Alloc_Vec_Vec_Type.t_vec ('k, 'v) (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VecMap a -> a
      end
end
module CreusotContracts_Model_DeepModel_DeepModelTy_Type
  type self
  type deepModelTy
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/invariant.rs" 16 4 16 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs" 49 8 49 27] (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Model_DeepModel_DeepModel_Stub
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Interface
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_DeepModel_DeepModel
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module Vecmap_KeySeqInternal_Stub
  type k
  type v
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function key_seq_internal [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 361 0 364 29] (v : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq DeepModelTy0.deepModelTy
    
end
module Vecmap_KeySeqInternal_Interface
  type k
  type v
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function key_seq_internal [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 361 0 364 29] (v : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq DeepModelTy0.deepModelTy
    
  val key_seq_internal [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 361 0 364 29] (v : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq DeepModelTy0.deepModelTy
    ensures { result = key_seq_internal v }
    
end
module Vecmap_KeySeqInternal
  type k
  type v
  use seq.Seq
  use prelude.Int
  use prelude.Mapping
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  function key_seq_internal [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 361 0 364 29] (v : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq DeepModelTy0.deepModelTy
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 367 8 367 56] Seq.create (Seq.length (ShallowModel0.shallow_model v)) (Mapping.from_fn (fun (i : int) -> DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) i in a)))
  val key_seq_internal [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 361 0 364 29] (v : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq DeepModelTy0.deepModelTy
    ensures { result = key_seq_internal v }
    
end
module Vecmap_Impl0_KeySeq_Stub
  type k
  type v
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  function key_seq [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 54 4 54 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
end
module Vecmap_Impl0_KeySeq_Interface
  type k
  type v
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  function key_seq [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 54 4 54 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
  val key_seq [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 54 4 54 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    ensures { result = key_seq self }
    
end
module Vecmap_Impl0_KeySeq
  type k
  type v
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone Vecmap_KeySeqInternal_Stub as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  function key_seq [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 54 4 54 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 55 8 55 32] KeySeqInternal0.key_seq_internal (Vecmap_VecMap_Type.vecmap_v self)
  val key_seq [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 54 4 54 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    ensures { result = key_seq self }
    
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
  val cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self _2 }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
  val cmp_log (self : self) (_2 : self) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self _2 }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub
  type self
  function le_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface
  type self
  function le_log (self : self) (o : self) : bool
  val le_log (self : self) (o : self) : bool
    ensures { result = le_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function le_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 11 20 11 56] CmpLog0.cmp_log self o <> Core_Cmp_Ordering_Type.C_Greater
  val le_log (self : self) (o : self) : bool
    ensures { result = le_log self o }
    
end
module CreusotContracts_Logic_Seq_Impl0_SortedRange_Stub
  type t
  use seq.Seq
  use prelude.Int
  predicate sorted_range (self : Seq.seq t) (l : int) (u : int)
end
module CreusotContracts_Logic_Seq_Impl0_SortedRange_Interface
  type t
  use seq.Seq
  use prelude.Int
  predicate sorted_range (self : Seq.seq t) (l : int) (u : int)
  val sorted_range (self : Seq.seq t) (l : int) (u : int) : bool
    ensures { result = sorted_range self l u }
    
end
module CreusotContracts_Logic_Seq_Impl0_SortedRange
  type t
  use seq.Seq
  use prelude.Int
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = t
  predicate sorted_range (self : Seq.seq t) (l : int) (u : int) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/seq.rs" 137 8 139 9] forall j : int . forall i : int . l <= i /\ i <= j /\ j < u -> LeLog0.le_log (Seq.get self i) (Seq.get self j)
  val sorted_range (self : Seq.seq t) (l : int) (u : int) : bool
    ensures { result = sorted_range self l u }
    
end
module CreusotContracts_Logic_Seq_Impl0_Sorted_Stub
  type t
  use seq.Seq
  predicate sorted (self : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl0_Sorted_Interface
  type t
  use seq.Seq
  predicate sorted (self : Seq.seq t)
  val sorted (self : Seq.seq t) : bool
    ensures { result = sorted self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Sorted
  type t
  use seq.Seq
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange_Stub as SortedRange0 with
    type t = t
  predicate sorted (self : Seq.seq t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/seq.rs" 148 8 148 40] SortedRange0.sorted_range self 0 (Seq.length self)
  val sorted (self : Seq.seq t) : bool
    ensures { result = sorted self }
    
end
module Vecmap_Impl1_Invariant_Stub
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 66 4 66 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
end
module Vecmap_Impl1_Invariant_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 66 4 66 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
  val invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 66 4 66 30] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_Impl1_Invariant
  type k
  type v
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Seq_Impl0_Sorted_Stub as Sorted0 with
    type t = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 66 4 66 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 67 8 67 31] Sorted0.sorted (KeySeq0.key_seq self)
  val invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 66 4 66 30] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = invariant' self }
    
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  val new (_1 : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 68 26 68 44] Seq.length (ShallowModel0.shallow_model result) = 0 }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 420 4 420 30] Inv0.inv result }
    
end
module Vecmap_VecMap_Type_Inv
  type k
  type v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Vecmap_Impl1_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  axiom inv_t_vecmap [@rewrite] : forall self : Vecmap_VecMap_Type.t_vecmap k v . Inv0.inv self = (Invariant0.invariant' self /\ Inv1.inv (Vecmap_VecMap_Type.vecmap_v self))
end
module CreusotContracts_Std1_Vec_Impl3_Invariant_Stub
  type t
  type a
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate invariant' (self : Alloc_Vec_Vec_Type.t_vec t a)
end
module CreusotContracts_Std1_Vec_Impl3_Invariant_Interface
  type t
  type a
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate invariant' (self : Alloc_Vec_Vec_Type.t_vec t a)
  val invariant' (self : Alloc_Vec_Vec_Type.t_vec t a) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Std1_Vec_Impl3_Invariant
  type t
  type a
  use seq.Seq
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv0.inv,
    axiom .
  predicate invariant' (self : Alloc_Vec_Vec_Type.t_vec t a) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 60 20 60 41] Inv0.inv (ShallowModel0.shallow_model self)
  val invariant' (self : Alloc_Vec_Vec_Type.t_vec t a) : bool
    ensures { result = invariant' self }
    
end
module Alloc_Vec_Vec_Type_Inv
  type t
  type a
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec t a
  clone CreusotContracts_Std1_Vec_Impl3_Invariant_Stub as Invariant0 with
    type t = t,
    type a = a
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  axiom inv_t_vec [@rewrite] : forall self : Alloc_Vec_Vec_Type.t_vec t a . Inv0.inv self = (Invariant0.invariant' self /\ Inv1.inv (Alloc_Vec_Vec_Type.vec_buf self))
end
module CreusotContracts_Logic_Seq_Seq_Type_Inv
  type t
  use prelude.Seq
  use prelude.Int
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Seq.seq t
  axiom inv_t_seq [@rewrite] : forall self : Seq.seq t . Inv0.inv self = (forall i : int . 0 <= i /\ i < Seq.length self -> Inv1.inv (Seq.get self i))
end
module Alloc_RawVec_RawVec_Type_Inv
  type t
  type a
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = a
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec t a
  axiom inv_t_rawvec [@rewrite] : forall self : Alloc_RawVec_RawVec_Type.t_rawvec t a . Inv0.inv self = (Inv1.inv (Alloc_RawVec_RawVec_Type.rawvec_ptr self) /\ Inv2.inv (Alloc_RawVec_RawVec_Type.rawvec_alloc self))
end
module TyInv_Tuple2
  type t0
  type t1
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t1
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = (t0, t1)
  axiom inv_tuple2 [@rewrite] : forall self : (t0, t1) . Inv0.inv self = (let (a_0, a_1) = self in Inv1.inv a_0 /\ Inv2.inv a_1)
end
module Core_Ptr_Unique_Unique_Type_Inv
  type t
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata t
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique t
  axiom inv_t_unique [@rewrite] : forall self : Core_Ptr_Unique_Unique_Type.t_unique t . Inv0.inv self = (Inv1.inv (Core_Ptr_Unique_Unique_Type.unique_pointer self) /\ Inv2.inv (Core_Ptr_Unique_Unique_Type.unique__marker self))
end
module Alloc_Alloc_Global_Type_Inv
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Alloc_Global_Type.t_global
  axiom inv_t_global : forall self : Alloc_Alloc_Global_Type.t_global . Inv0.inv self = true
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_le_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_le_log (x : self) (y : self) : ()
  val cmp_le_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 4 16 36] Inv1.inv result }
    ensures { result = cmp_le_log x y }
    
  axiom cmp_le_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 4 16 36] Inv1.inv (cmp_le_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_le_log (x : self) (y : self) : ()
  val cmp_le_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 4 16 36] Inv1.inv result }
    ensures { result = cmp_le_log x y }
    
  axiom cmp_le_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 18 16 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 27 16 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 16 4 16 36] Inv1.inv (cmp_le_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 15 14 15 64] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub
  type self
  function lt_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface
  type self
  function lt_log (self : self) (o : self) : bool
  val lt_log (self : self) (o : self) : bool
    ensures { result = lt_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function lt_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 21 20 21 53] CmpLog0.cmp_log self o = Core_Cmp_Ordering_Type.C_Less
  val lt_log (self : self) (o : self) : bool
    ensures { result = lt_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_lt_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_lt_log (x : self) (y : self) : ()
  val cmp_lt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 4 26 36] Inv1.inv result }
    ensures { result = cmp_lt_log x y }
    
  axiom cmp_lt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 4 26 36] Inv1.inv (cmp_lt_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_lt_log (x : self) (y : self) : ()
  val cmp_lt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 4 26 36] Inv1.inv result }
    ensures { result = cmp_lt_log x y }
    
  axiom cmp_lt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 18 26 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 27 26 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 26 4 26 36] Inv1.inv (cmp_lt_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 25 14 25 61] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub
  type self
  function ge_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface
  type self
  function ge_log (self : self) (o : self) : bool
  val ge_log (self : self) (o : self) : bool
    ensures { result = ge_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function ge_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 31 20 31 53] CmpLog0.cmp_log self o <> Core_Cmp_Ordering_Type.C_Less
  val ge_log (self : self) (o : self) : bool
    ensures { result = ge_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_ge_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_ge_log (x : self) (y : self) : ()
  val cmp_ge_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 4 36 36] Inv1.inv result }
    ensures { result = cmp_ge_log x y }
    
  axiom cmp_ge_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 4 36 36] Inv1.inv (cmp_ge_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_ge_log (x : self) (y : self) : ()
  val cmp_ge_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 4 36 36] Inv1.inv result }
    ensures { result = cmp_ge_log x y }
    
  axiom cmp_ge_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 18 36 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 27 36 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 36 4 36 36] Inv1.inv (cmp_ge_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 35 14 35 61] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less))
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub
  type self
  function gt_log (self : self) (o : self) : bool
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface
  type self
  function gt_log (self : self) (o : self) : bool
  val gt_log (self : self) (o : self) : bool
    ensures { result = gt_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function gt_log (self : self) (o : self) : bool =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 41 20 41 56] CmpLog0.cmp_log self o = Core_Cmp_Ordering_Type.C_Greater
  val gt_log (self : self) (o : self) : bool
    ensures { result = gt_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_gt_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_gt_log (x : self) (y : self) : ()
  val cmp_gt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 4 46 36] Inv1.inv result }
    ensures { result = cmp_gt_log x y }
    
  axiom cmp_gt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 4 46 36] Inv1.inv (cmp_gt_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function cmp_gt_log (x : self) (y : self) : ()
  val cmp_gt_log (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 4 46 36] Inv1.inv result }
    ensures { result = cmp_gt_log x y }
    
  axiom cmp_gt_log_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 18 46 19] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 27 46 28] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 46 4 46 36] Inv1.inv (cmp_gt_log x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 45 14 45 64] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater))
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function refl (x : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function refl (x : self) : ()
  val refl (x : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 4 50 21] Inv1.inv result }
    ensures { result = refl x }
    
  axiom refl_spec : forall x : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 4 50 21] Inv1.inv (refl x)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal)
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function refl (x : self) : ()
  val refl (x : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 4 50 21] Inv1.inv result }
    ensures { result = refl x }
    
  axiom refl_spec : forall x : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 12 50 13] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 50 4 50 21] Inv1.inv (refl x)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 49 14 49 45] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal)
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
  val trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 40 56 41] Inv1.inv o}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 4 56 53] Inv2.inv result }
    ensures { result = trans x y z o }
    
  axiom trans_spec : forall x : self, y : self, z : self, o : Core_Cmp_Ordering_Type.t_ordering . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 40 56 41] Inv1.inv o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 4 56 53] Inv2.inv (trans x y z o)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o)
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
  val trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 40 56 41] Inv1.inv o}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 4 56 53] Inv2.inv result }
    ensures { result = trans x y z o }
    
  axiom trans_spec : forall x : self, y : self, z : self, o : Core_Cmp_Ordering_Type.t_ordering . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 53 15 53 32] CmpLog0.cmp_log x y = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 54 15 54 32] CmpLog0.cmp_log y z = o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 13 56 14] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 22 56 23] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 31 56 32] Inv0.inv z) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 40 56 41] Inv1.inv o) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 56 4 56 53] Inv2.inv (trans x y z o)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 55 14 55 31] CmpLog0.cmp_log x z = o)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
  val antisym1 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 4 61 34] Inv1.inv result }
    ensures { result = antisym1 x y }
    
  axiom antisym1_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 4 61 34] Inv1.inv (antisym1 x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
  val antisym1 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 4 61 34] Inv1.inv result }
    ensures { result = antisym1 x y }
    
  axiom antisym1_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 59 15 59 45] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 16 61 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 25 61 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 61 4 61 34] Inv1.inv (antisym1 x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 60 14 60 47] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
  val antisym2 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 4 66 34] Inv1.inv result }
    ensures { result = antisym2 x y }
    
  axiom antisym2_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 4 66 34] Inv1.inv (antisym2 x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
  val antisym2 (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 4 66 34] Inv1.inv result }
    ensures { result = antisym2 x y }
    
  axiom antisym2_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 64 15 64 48] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 16 66 17] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 25 66 26] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 66 4 66 34] Inv1.inv (antisym2 x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 65 14 65 44] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Stub
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function eq_cmp (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function eq_cmp (x : self) (y : self) : ()
  val eq_cmp (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 4 70 32] Inv1.inv result }
    ensures { result = eq_cmp x y }
    
  axiom eq_cmp_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 4 70 32] Inv1.inv (eq_cmp x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal))
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp
  type self
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  function eq_cmp (x : self) (y : self) : ()
  val eq_cmp (x : self) (y : self) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 4 70 32] Inv1.inv result }
    ensures { result = eq_cmp x y }
    
  axiom eq_cmp_spec : forall x : self, y : self . ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 14 70 15] Inv0.inv x) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 23 70 24] Inv0.inv y) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 70 4 70 32] Inv1.inv (eq_cmp x y)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal))
end
module Core_Ptr_NonNull_NonNull_Type_Inv
  type t
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull t
  axiom inv_t_nonnull : forall self : Core_Ptr_NonNull_NonNull_Type.t_nonnull t . Inv0.inv self = true
end
module Core_Marker_PhantomData_Type_Inv
  type t
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata t
  axiom inv_t_phantomdata : forall self : Core_Marker_PhantomData_Type.t_phantomdata t . Inv0.inv self = true
end
module TyInv_Tuple0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = ()
  axiom inv_tuple0 : forall self : () . Inv0.inv self = true
end
module Core_Cmp_Ordering_Type_Inv
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  axiom inv_t_ordering : forall self : Core_Cmp_Ordering_Type.t_ordering . Inv0.inv self = true
end
module Vecmap_Impl2_New_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val new [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 76 4 76 24] (_1 : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 76 20 76 24] Inv0.inv result }
    
end
module Vecmap_Impl2_New
  type k
  type v
  use seq.Seq
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv13.inv,
    predicate Inv2.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = v,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv9.inv,
    predicate Inv2.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX'
  clone Vecmap_Impl1_Invariant as Invariant0 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv2.inv
  let rec cfg new [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 76 4 76 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 76 20 76 24] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_VecMap_Type.t_vecmap k v;
  var _1 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    _1 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 77 18 77 28] New0.new ());
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_VecMap_Type.C_VecMap _1;
    _1 <- any Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_VacantEntry_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  type t_vacantentry 'k 'v =
    | C_VacantEntry (borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)) 'k usize
    
  let function vacantentry_map (self : t_vacantentry 'k 'v) : borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry a _ _ -> a
      end
  let function vacantentry_key (self : t_vacantentry 'k 'v) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry _ a _ -> a
      end
  let function vacantentry_index (self : t_vacantentry 'k 'v) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry _ _ a -> a
      end
end
module Vecmap_OccupiedEntry_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  type t_occupiedentry 'k 'v =
    | C_OccupiedEntry (borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)) 'k usize
    
  let function occupiedentry_map (self : t_occupiedentry 'k 'v) : borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry a _ _ -> a
      end
  let function occupiedentry_key (self : t_occupiedentry 'k 'v) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry _ a _ -> a
      end
  let function occupiedentry_index (self : t_occupiedentry 'k 'v) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry _ _ a -> a
      end
end
module Vecmap_Entry_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  type t_entry 'k 'v =
    | C_Vacant (Vecmap_VacantEntry_Type.t_vacantentry 'k 'v)
    | C_Occupied (Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v)
    
  let function vacant_0 (self : t_entry 'k 'v) : Vecmap_VacantEntry_Type.t_vacantentry 'k 'v
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Vacant a -> a
      | C_Occupied _ -> any Vecmap_VacantEntry_Type.t_vacantentry 'k 'v
      end
  let function occupied_0 (self : t_entry 'k 'v) : Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Vacant _ -> any Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v
      | C_Occupied a -> a
      end
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module Core_Result_Result_Type
  type t_result 't 'e =
    | C_Ok 't
    | C_Err 'e
    
  let function ok_0 (self : t_result 't 'e) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ok a -> a
      | C_Err _ -> any 't
      end
  let function err_0 (self : t_result 't 'e) : 'e = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ok _ -> any 'e
      | C_Err a -> a
      end
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module TyInv_Borrow_Shared
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_borrow_shared [@rewrite] : forall self : t . Inv0.inv self = Inv1.inv self
end
module CreusotContracts_Model_Impl4_DeepModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_Impl4_DeepModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_Impl4_DeepModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = t,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model (self : t) : DeepModelTy0.deepModelTy =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/model.rs" 74 8 74 28] DeepModel0.deep_model self
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Contains_Stub
  type t
  use seq.Seq
  predicate contains (self : Seq.seq t) (e : t)
end
module CreusotContracts_Logic_Seq_Impl0_Contains_Interface
  type t
  use seq.Seq
  predicate contains (self : Seq.seq t) (e : t)
  val contains (self : Seq.seq t) (e : t) : bool
    ensures { result = contains self e }
    
end
module CreusotContracts_Logic_Seq_Impl0_Contains
  type t
  use seq.Seq
  use prelude.Int
  predicate contains (self : Seq.seq t) (e : t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/seq.rs" 128 8 128 78] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = e
  val contains (self : Seq.seq t) (e : t) : bool
    ensures { result = contains self e }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl5_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/model.rs" 83 8 83 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = usize
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  val len (self : Alloc_Vec_Vec_Type.t_vec t a) : usize
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2049 16 2049 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 75 26 75 48] UIntSize.to_int result = Seq.length (ShallowModel0.shallow_model self) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2049 4 2049 30] Inv1.inv result }
    
end
module CreusotContracts_Logic_Int_Int_Type_Inv
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = int
  axiom inv_t_int : forall self : int . Inv0.inv self = true
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module Alloc_Vec_Impl12_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 141 27 141 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2673 14 2673 18] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2673 20 2673 25] Inv1.inv index}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 142 26 142 54] HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2673 4 2673 46] Inv2.inv result }
    
end
module Core_Cmp_Ord_Cmp_Interface
  type self
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  val cmp (self : self) (other : self) : Core_Cmp_Ordering_Type.t_ordering
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 775 12 775 16] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 775 18 775 23] Inv0.inv other}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/cmp.rs" 44 26 44 85] result = CmpLog0.cmp_log (DeepModel0.deep_model self) (DeepModel0.deep_model other) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 775 4 775 44] Inv1.inv result }
    
end
module Core_Result_Result_Type_Inv
  type t
  type e
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = e
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Result_Result_Type.t_result t e
  axiom inv_t_result [@rewrite] : forall self : Core_Result_Result_Type.t_result t e . Inv0.inv self = match (self) with
    | Core_Result_Result_Type.C_Ok a_0 -> Inv1.inv (Core_Result_Result_Type.ok_0 self)
    | Core_Result_Result_Type.C_Err a_0 -> Inv2.inv (Core_Result_Result_Type.err_0 self)
    end
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 108 20 108 37] UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 115 20 115 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module Vecmap_Impl2_FindK_Interface
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = int
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = usize
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val find_k [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 4 297 53] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Result_Result_Type.t_result usize usize
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 15 297 19] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 21 297 24] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 284 14 287 5] match (result) with
      | Core_Result_Result_Type.C_Ok _ -> Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      | Core_Result_Result_Type.C_Err _ -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      end }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 288 4 288 91] forall i : usize . Inv2.inv i -> result = Core_Result_Result_Type.C_Ok i -> Seq.get (KeySeq0.key_seq self) (UIntSize.to_int i) = DeepModel0.deep_model key }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 289 4 290 52] forall j : int . forall i : usize . Inv3.inv j -> Inv2.inv i -> result = Core_Result_Result_Type.C_Err i -> j >= UIntSize.to_int i /\ j < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 291 4 292 52] forall j : int . forall i : usize . Inv3.inv j -> Inv2.inv i -> result = Core_Result_Result_Type.C_Err i /\ j >= 0 /\ j < UIntSize.to_int i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 293 14 296 5] match (result) with
      | Core_Result_Result_Type.C_Ok idx -> UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      | Core_Result_Result_Type.C_Err idx -> UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      end }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 33 297 53] Inv4.inv result }
    
end
module Vecmap_Impl2_FindK
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv20.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv18.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv20.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = v,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv17.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv12.inv,
    predicate Inv2.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv13.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv7.inv,
    val Max0.mAX' = Max0.mAX'
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv7.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone Core_Result_Result_Type_Inv as Core_Result_Result_Type_Inv0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = usize,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = (k, v),
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv9.inv,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone Core_Cmp_Ord_Cmp_Interface as Cmp0 with
    type self = k,
    predicate Inv0.inv = Inv1.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv4.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv3.inv,
    type Output0.output = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv4.inv
  let rec cfg find_k [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 4 297 53] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Result_Result_Type.t_result usize usize
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 15 297 19] Inv2.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 21 297 24] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 284 14 287 5] match (result) with
      | Core_Result_Result_Type.C_Ok _ -> Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      | Core_Result_Result_Type.C_Err _ -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      end }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 288 4 288 91] forall i : usize . Inv4.inv i -> result = Core_Result_Result_Type.C_Ok i -> Seq.get (KeySeq0.key_seq self) (UIntSize.to_int i) = DeepModel0.deep_model key }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 289 4 290 52] forall j : int . forall i : usize . Inv0.inv j -> Inv4.inv i -> result = Core_Result_Result_Type.C_Err i -> j >= UIntSize.to_int i /\ j < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 291 4 292 52] forall j : int . forall i : usize . Inv0.inv j -> Inv4.inv i -> result = Core_Result_Result_Type.C_Err i /\ j >= 0 /\ j < UIntSize.to_int i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 293 14 296 5] match (result) with
      | Core_Result_Result_Type.C_Ok idx -> UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      | Core_Result_Result_Type.C_Err idx -> UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      end }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 297 33 297 53] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Result_Result_Type.t_result usize usize;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : k = key;
  var size : usize;
  var left : usize;
  var right : usize;
  var mid : usize;
  var _28 : bool;
  var cmp : Core_Cmp_Ordering_Type.t_ordering;
  var _31 : (k, v);
  var _35 : ();
  {
    goto BB0
  }
  BB0 {
    size <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 300 23 300 35] Len0.len (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    left <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 301 23 301 24] (0 : usize));
    right <- size;
    goto BB2
  }
  BB2 {
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 305 20 305 58] UIntSize.to_int size >= 0 /\ UIntSize.to_int size <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 306 20 306 58] UIntSize.to_int left >= 0 /\ UIntSize.to_int left <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 307 20 307 60] UIntSize.to_int right >= 0 /\ UIntSize.to_int right <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 305 8 305 60] UIntSize.to_int left < UIntSize.to_int right -> UIntSize.to_int left + div (UIntSize.to_int size) 2 < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 305 8 305 60] UIntSize.to_int left < UIntSize.to_int right -> UIntSize.to_int right > UIntSize.to_int left + div (UIntSize.to_int size) 2 };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 305 8 305 60] forall i : int . Inv0.inv i -> i >= UIntSize.to_int right /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model key) };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 305 8 305 60] forall i : int . Inv0.inv i -> i >= 0 /\ i < UIntSize.to_int left -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model key) };
    goto BB3
  }
  BB3 {
    switch ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 314 14 314 26] left < right)
      | False -> goto BB15
      | True -> goto BB4
      end
  }
  BB4 {
    _28 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 315 25 315 33] ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 315 32 315 33] (2 : usize)) = ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 315 25 315 33] (0 : usize)));
    assert { [@expl:division by zero] [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 315 25 315 33] not _28 };
    goto BB5
  }
  BB5 {
    mid <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 315 12 315 33] left + ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 315 25 315 33] size / ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 315 32 315 33] (2 : usize))));
    _31 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 317 22 317 33] Index0.index (Vecmap_VecMap_Type.vecmap_v self) mid);
    goto BB6
  }
  BB6 {
    assert { [@expl:type invariant] Inv3.inv _31 };
    assume { Resolve2.resolve _31 };
    cmp <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 317 22 317 44] Cmp0.cmp (let (a, _) = _31 in a) key);
    goto BB7
  }
  BB7 {
    switch (cmp)
      | Core_Cmp_Ordering_Type.C_Less -> goto BB8
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB9
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB10
      end
  }
  BB8 {
    goto BB12
  }
  BB9 {
    _0 <- Core_Result_Result_Type.C_Ok mid;
    goto BB16
  }
  BB10 {
    goto BB13
  }
  BB11 {
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB12 {
    left <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 320 34 320 48] mid + ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 320 47 320 48] (1 : usize)));
    _35 <- ();
    goto BB14
  }
  BB13 {
    right <- mid;
    _35 <- ();
    goto BB14
  }
  BB14 {
    size <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 325 12 325 31] right - left);
    goto BB2
  }
  BB15 {
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Result_Result_Type.C_Err left;
    goto BB16
  }
  BB16 {
    return _0
  }
  BB18 {
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    goto BB9
  }
  BB19 {
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve0.resolve key };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    goto BB9
  }
  
end
module TyInv_Borrow
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  axiom inv_borrow [@rewrite] : forall self : borrowed t . Inv0.inv self = (Inv1.inv ( * self) /\ Inv1.inv ( ^ self))
end
module Vecmap_Entry_Type_Inv
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_Entry_Type.t_entry k v
  axiom inv_t_entry [@rewrite] : forall self : Vecmap_Entry_Type.t_entry k v . Inv0.inv self = match (self) with
    | Vecmap_Entry_Type.C_Vacant a_0 -> Inv1.inv (Vecmap_Entry_Type.vacant_0 self)
    | Vecmap_Entry_Type.C_Occupied a_0 -> Inv2.inv (Vecmap_Entry_Type.occupied_0 self)
    end
end
module Vecmap_Impl4_Invariant_Stub
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 439 4 439 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
end
module Vecmap_Impl4_Invariant_Interface
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 439 4 439 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
  val invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 439 4 439 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_Impl4_Invariant
  type k
  type v
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 439 4 439 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 441 12 441 46] UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self)))
  val invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 439 4 439 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_VacantEntry_Type_Inv
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = k
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl4_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  axiom inv_t_vacantentry [@rewrite] : forall self : Vecmap_VacantEntry_Type.t_vacantentry k v . Inv0.inv self = (Invariant0.invariant' self /\ (Inv1.inv ( * Vecmap_VacantEntry_Type.vacantentry_map self) /\ Inv1.inv ( ^ Vecmap_VacantEntry_Type.vacantentry_map self)) /\ Inv2.inv (Vecmap_VacantEntry_Type.vacantentry_key self))
end
module Vecmap_Impl6_Invariant_Stub
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 469 4 469 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
    
end
module Vecmap_Impl6_Invariant_Interface
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 469 4 469 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
    
  val invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 469 4 469 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_Impl6_Invariant
  type k
  type v
  use prelude.Borrow
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 469 4 469 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 471 16 472 72] Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self))) > UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index self) /\ Seq.get (KeySeq0.key_seq ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self)) (UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index self)) = DeepModel0.deep_model (Vecmap_OccupiedEntry_Type.occupiedentry_key self)
  val invariant' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 469 4 469 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_OccupiedEntry_Type_Inv
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = k
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl6_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  axiom inv_t_occupiedentry [@rewrite] : forall self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . Inv0.inv self = (Invariant0.invariant' self /\ (Inv1.inv ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self) /\ Inv1.inv ( ^ Vecmap_OccupiedEntry_Type.occupiedentry_map self)) /\ Inv2.inv (Vecmap_OccupiedEntry_Type.occupiedentry_key self))
end
module Vecmap_Impl2_Entry_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  val entry [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 4 82 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 22 82 26] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 28 82 31] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 39 82 50] Inv2.inv result }
    
end
module Vecmap_Impl2_Entry
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv22.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = v,
    predicate Inv0.inv = Inv20.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv19.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv21.inv,
    predicate Inv2.inv = Inv22.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl6_Invariant as Invariant3 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl4_Invariant as Invariant2 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv20.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv16.inv,
    predicate Inv1.inv = Inv18.inv,
    predicate Inv2.inv = Inv19.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv12.inv,
    predicate Invariant0.invariant' = Invariant3.invariant',
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv11.inv,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_Invariant as Invariant0 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv17.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv9.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv16.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone Core_Result_Result_Type_Inv as Core_Result_Result_Type_Inv0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv15.inv,
    predicate Inv2.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv13.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone Vecmap_Entry_Type_Inv as Vecmap_Entry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv12.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl2_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    predicate Inv2.inv = Inv6.inv,
    predicate Inv3.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv4.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv5.inv = Inv9.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv6.inv = Inv10.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg entry [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 4 82 50] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 22 82 26] Inv2.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 28 82 31] Inv3.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 82 39 82 50] Inv4.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_Entry_Type.t_entry k v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key : k = key;
  var _3 : Core_Result_Result_Type.t_result usize usize;
  var _6 : k;
  var index : usize;
  var _10 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var index1 : usize;
  var _15 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  {
    goto BB0
  }
  BB0 {
    _6 <- key;
    assert { [@expl:type invariant] Inv0.inv _6 };
    assume { Resolve0.resolve _6 };
    _3 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 83 14 83 31] FindK0.find_k ( * self) _6);
    goto BB1
  }
  BB1 {
    switch (_3)
      | Core_Result_Result_Type.C_Ok _ -> goto BB2
      | Core_Result_Result_Type.C_Err _ -> goto BB3
      end
  }
  BB2 {
    goto BB5
  }
  BB3 {
    index1 <- Core_Result_Result_Type.err_0 _3;
    _15 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _15) };
    assume { Inv1.inv ( ^ _15) };
    goto BB8
  }
  BB4 {
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve2.resolve key };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB5 {
    index <- Core_Result_Result_Type.ok_0 _3;
    _10 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _10) };
    assume { Inv1.inv ( ^ _10) };
    goto BB6
  }
  BB6 {
    _0 <- Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry _10 key index);
    _10 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB7
  }
  BB7 {
    goto BB10
  }
  BB8 {
    _0 <- Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry _15 key index1);
    _15 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    return _0
  }
  
end
module Vecmap_KeyRef_Type
  use prelude.Int
  use prelude.UIntSize
  type t_keyref 'k =
    | C_KeyRef 'k usize
    
  let function keyref_key (self : t_keyref 'k) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_KeyRef a _ -> a
      end
  let function keyref_min_idx (self : t_keyref 'k) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_KeyRef _ a -> a
      end
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module CreusotContracts_Logic_Seq_Impl0_Get_Stub
  type t
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
end
module CreusotContracts_Logic_Seq_Impl0_Get_Interface
  type t
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
  val get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
    ensures { result = get self ix }
    
end
module CreusotContracts_Logic_Seq_Impl0_Get
  type t
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/seq.rs" 23 4 23 12] if 0 <= ix /\ ix < Seq.length self then
      Core_Option_Option_Type.C_Some (Seq.get self ix)
    else
      Core_Option_Option_Type.C_None
    
  val get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
    ensures { result = get self ix }
    
end
module Vecmap_Impl2_IsValidKeyrefLg_Stub
  type k
  type v
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_valid_keyref_lg [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 243 4 243 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
end
module Vecmap_Impl2_IsValidKeyrefLg_Interface
  type k
  type v
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_valid_keyref_lg [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 243 4 243 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
  val is_valid_keyref_lg [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 243 4 243 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    ensures { result = is_valid_keyref_lg self key }
    
end
module Vecmap_Impl2_IsValidKeyrefLg
  type k
  type v
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get_Stub as Get0 with
    type t = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  predicate is_valid_keyref_lg [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 243 4 243 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 245 12 250 13] match (Get0.get (KeySeq0.key_seq self) (UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key))) with
      | Core_Option_Option_Type.C_Some k -> LeLog0.le_log k (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))
      | _ -> false
      end
  val is_valid_keyref_lg [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 243 4 243 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    ensures { result = is_valid_keyref_lg self key }
    
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
  val produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = produces self visited o }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces
  type idx
  use seq.Seq
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
   =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 21 8 27 9] Core_Ops_Range_Range_Type.range_end self = Core_Ops_Range_Range_Type.range_end o /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) /\ (Seq.length visited > 0 -> DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end o)) /\ Seq.length visited = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) - DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> DeepModel0.deep_model (Seq.get visited i) = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) + i)
  val produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = produces self visited o }
    
end
module Vecmap_Impl8_DeepModel_Stub
  type k
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 510 4 510 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
end
module Vecmap_Impl8_DeepModel_Interface
  type k
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 510 4 510 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
  val deep_model [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 510 4 510 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    ensures { result = deep_model self }
    
end
module Vecmap_Impl8_DeepModel
  type k
  use prelude.Int
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 510 4 510 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 511 19 511 57] (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key self), UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx self))
  val deep_model [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 510 4 510 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    ensures { result = deep_model self }
    
end
module Vecmap_KeyRef_Type_Inv
  type k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  axiom inv_t_keyref [@rewrite] : forall self : Vecmap_KeyRef_Type.t_keyref k . Inv0.inv self = Inv1.inv (Vecmap_KeyRef_Type.keyref_key self)
end
module Vecmap_Impl10_AsRef_Interface
  type k
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, int)
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  val as_ref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 525 4 525 38] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 525 19 525 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 524 14 524 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 525 28 525 38] Inv1.inv result }
    
end
module Vecmap_Impl10_AsRef
  type k
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv1 with
    type k = k,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel4 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel3 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Vecmap_Impl8_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone Vecmap_Impl8_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, int),
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg as_ref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 525 4 525 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 525 19 525 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 524 14 524 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 525 28 525 38] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_KeyRef_Type.t_keyref k = self;
  var _5 : k;
  {
    goto BB0
  }
  BB0 {
    _5 <- Vecmap_KeyRef_Type.keyref_key self;
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv _5 };
    assume { Resolve1.resolve _5 };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _5 (Vecmap_KeyRef_Type.keyref_min_idx self);
    return _0
  }
  
end
module Vecmap_Impl11_ToOwned_Stub
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  function to_owned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 4 533 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
end
module Vecmap_Impl11_ToOwned_Interface
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  function to_owned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 4 533 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
  val to_owned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 4 533 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 16 533 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 532 14 532 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 25 533 34] Inv1.inv result }
    ensures { result = to_owned self }
    
  axiom to_owned_spec : forall self : Vecmap_KeyRef_Type.t_keyref k . ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 16 533 20] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 25 533 34] Inv1.inv (to_owned self)) && ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 532 14 532 54] DeepModel0.deep_model self = DeepModel1.deep_model (to_owned self))
end
module Vecmap_Impl11_ToOwned
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  function to_owned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 4 533 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 534 8 534 56] Vecmap_KeyRef_Type.C_KeyRef (Vecmap_KeyRef_Type.keyref_key self) (Vecmap_KeyRef_Type.keyref_min_idx self)
  val to_owned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 4 533 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 16 533 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 532 14 532 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 25 533 34] Inv1.inv result }
    ensures { result = to_owned self }
    
  axiom to_owned_spec : forall self : Vecmap_KeyRef_Type.t_keyref k . ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 16 533 20] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 25 533 34] Inv1.inv (to_owned self)) && ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 532 14 532 54] DeepModel0.deep_model self = DeepModel1.deep_model (to_owned self))
end
module Vecmap_Impl11_ToOwned_Impl
  type k
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv1 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel3 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel2 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone Vecmap_Impl8_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Vecmap_Impl8_DeepModel as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model
  let rec ghost function to_owned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 4 533 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 16 533 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 532 14 532 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 533 25 533 34] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 534 8 534 56] Vecmap_KeyRef_Type.C_KeyRef (Vecmap_KeyRef_Type.keyref_key self) (Vecmap_KeyRef_Type.keyref_min_idx self)
end
module Alloc_Vec_Impl8_Deref_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = slice t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  val deref (self : Alloc_Vec_Vec_Type.t_vec t a) : slice t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2608 14 2608 18] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 147 26 147 42] ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2608 4 2608 27] Inv1.inv result }
    
end
module Core_Slice_Impl0_Get_Interface
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val get (self : slice t) (index : i) : Core_Option_Option_Type.t_option Output0.output
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 601 19 601 23] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 601 25 601 30] Inv1.inv index}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 245 8 245 102] InBounds0.in_bounds index (ShallowModel0.shallow_model self) -> (exists r : Output0.output . Inv2.inv r /\ result = Core_Option_Option_Type.C_Some r /\ HasValue0.has_value index (ShallowModel0.shallow_model self) r) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 246 18 246 55] InBounds0.in_bounds index (ShallowModel0.shallow_model self) \/ result = Core_Option_Option_Type.C_None }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 601 4 603 28] Inv3.inv result }
    
end
module Core_Option_Option_Type_Inv
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  axiom inv_t_option [@rewrite] : forall self : Core_Option_Option_Type.t_option t . Inv0.inv self = match (self) with
    | Core_Option_Option_Type.C_None -> true
    | Core_Option_Option_Type.C_Some a_0 -> Inv1.inv (Core_Option_Option_Type.some_0 self)
    end
end
module Core_Cmp_Impls_Impl10_Le_Interface
  type a
  type b
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = bool
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel1 with
    type t = b,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = b
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = a
  val le (self : a) (other : b) : bool
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1470 15 1470 19] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1470 21 1470 26] Inv1.inv other}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/cmp.rs" 30 26 30 77] result = LeLog0.le_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1470 8 1470 40] Inv2.inv result }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] result = Slice.id self }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] result = Slice.id self }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 21 19 25] Inv0.inv self) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 19 4 19 50] Inv1.inv (shallow_model self)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module TyInv_Slice
  type t
  use prelude.Slice
  use prelude.Seq
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  axiom inv_slice [@rewrite] : forall self : slice t . Inv0.inv self = (forall i : int . 0 <= i /\ i < Seq.length (Slice.id self) -> Inv1.inv (Seq.get (Slice.id self) i))
end
module Vecmap_Impl2_IsValidKeyref_Interface
  type k
  type v
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl8_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = bool
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = int
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone Vecmap_Impl2_IsValidKeyrefLg_Stub as IsValidKeyrefLg0 with
    type k = k,
    type v = v
  clone Vecmap_Impl11_ToOwned_Stub as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv4.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    predicate Inv1.inv = Inv5.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val is_valid_keyref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 4 235 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 24 235 28] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 30 235 33] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 231 14 231 66] result = IsValidKeyrefLg0.is_valid_keyref_lg self (ToOwned0.to_owned key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 232 4 232 57] result -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 233 4 234 57] result -> (forall i : int . Inv2.inv i -> i >= 0 /\ i <= UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 51 235 55] Inv3.inv result }
    
end
module Vecmap_Impl2_IsValidKeyref
  type k
  type v
  use prelude.Borrow
  use prelude.Slice
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv27 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv27.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv26 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv26.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv25 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv25.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv24 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv24.inv,
    predicate Inv1.inv = Inv26.inv,
    predicate Inv2.inv = Inv27.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv23 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = v,
    predicate Inv0.inv = Inv23.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv22.inv,
    predicate Inv1.inv = Inv24.inv,
    predicate Inv2.inv = Inv25.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv21.inv,
    predicate Inv1.inv = Inv17.inv,
    predicate Inv2.inv = Inv23.inv,
    axiom .
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel4 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel4.deep_model,
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv14.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv20.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX'
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = slice (k, v)
  clone TyInv_Slice as TyInv_Slice0 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv15.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv13.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv22.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv1 with
    type k = k,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared6 with
    type t = k,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared5 with
    type t = (k, v),
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel3 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = bool
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = bool,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv20.inv,
    predicate Inv2.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv19.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get1 with
    type t = DeepModelTy0.deepModelTy
  clone Vecmap_Impl8_DeepModel as DeepModel3 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Vecmap_Impl8_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared3 with
    type t = k,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option (k, v)
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = slice (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = slice (k, v),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone Vecmap_Impl2_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get1.get
  clone Vecmap_Impl11_ToOwned as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv11.inv,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel3.deep_model,
    predicate Inv1.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = k
  clone Core_Cmp_Impls_Impl10_Le_Interface as Le0 with
    type a = k,
    type b = k,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv10.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    predicate Inv2.inv = Inv6.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = (k, v),
    type i = usize,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv8.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = (k, v),
    predicate Inv2.inv = Inv9.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv3.inv = Inv2.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = slice (k, v)
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    predicate Inv1.inv = Inv1.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg is_valid_keyref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 4 235 55] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 24 235 28] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 30 235 33] Inv3.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 231 14 231 66] result = IsValidKeyrefLg0.is_valid_keyref_lg self (ToOwned0.to_owned key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 232 4 232 57] result -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 233 4 234 57] result -> (forall i : int . Inv5.inv i -> i >= 0 /\ i <= UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 235 51 235 55] Inv6.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : Vecmap_KeyRef_Type.t_keyref k = key;
  var _6 : Core_Option_Option_Type.t_option (k, v);
  var _8 : slice (k, v);
  var k : k;
  var _15 : k;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _8 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 236 14 236 37] Deref0.deref (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv _8 };
    assume { Resolve1.resolve _8 };
    _6 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 236 14 236 37] Get0.get _8 (Vecmap_KeyRef_Type.keyref_min_idx key));
    goto BB2
  }
  BB2 {
    switch (_6)
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      | _ -> goto BB3
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv _6 };
    assume { Resolve2.resolve _6 };
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    _0 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 238 17 238 22] false);
    goto BB7
  }
  BB4 {
    goto BB5
  }
  BB5 {
    k <- (let (a, _) = Core_Option_Option_Type.some_0 _6 in a);
    assert { [@expl:type invariant] Inv2.inv _6 };
    assume { Resolve2.resolve _6 };
    _15 <- Vecmap_KeyRef_Type.keyref_key key;
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    _0 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 237 28 237 40] Le0.le k _15);
    goto BB6
  }
  BB6 {
    assert { [@expl:type invariant] Inv4.inv _15 };
    assume { Resolve4.resolve _15 };
    assert { [@expl:type invariant] Inv4.inv k };
    assume { Resolve4.resolve k };
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Interface
  type self
  predicate into_iter_pre (self : self)
  val into_iter_pre (self : self) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre
  type self
  predicate into_iter_pre (self : self) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 63 20 63 24] true
  val into_iter_pre (self : self) : bool
    ensures { result = into_iter_pre self }
    
end
module Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type
  type self
  type intoIter
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Interface
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
  val into_iter_post (self : self) (res : IntoIter0.intoIter) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
  val into_iter_post (self : self) (res : IntoIter0.intoIter) : bool
    ensures { result = into_iter_post self res }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Interface
  type i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub as IntoIterPost0 with
    type self = i,
    type IntoIter0.intoIter = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub as IntoIterPre0 with
    type self = i
  val into_iter (self : i) : i
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 89 0 166 1] IntoIterPre0.into_iter_pre self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs" 281 17 281 21] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 89 0 166 1] IntoIterPost0.into_iter_post self result }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs" 281 4 281 27] Inv0.inv result }
    
end
module Core_Ops_Range_Range_Type_Inv
  type idx
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  axiom inv_t_range [@rewrite] : forall self : Core_Ops_Range_Range_Type.t_range idx . Inv0.inv self = (Inv1.inv (Core_Ops_Range_Range_Type.range_start self) /\ Inv1.inv (Core_Ops_Range_Range_Type.range_end self))
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Stub
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Interface
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Iter_Iterator_Completed
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module Core_Iter_Traits_Iterator_Iterator_Item_Type
  type self
  type item
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Stub
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_o : self) : bool
    ensures { result = produces self visited _o }
    
end
module CreusotContracts_Std1_Iter_Iterator_Produces
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_o : self) : bool
    ensures { result = produces self visited _o }
    
end
module Core_Iter_Range_Impl3_Next_Interface
  type a
  use prelude.Borrow
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Option_Option_Type.t_option a
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces0 with
    type self = Core_Ops_Range_Range_Type.t_range a,
    type Item0.item = a
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range a)
  val next (self : borrowed (Core_Ops_Range_Range_Type.t_range a)) : Core_Option_Option_Type.t_option a
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs" 711 17 711 21] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 95 26 98 17] match (result) with
      | Core_Option_Option_Type.C_None -> Completed0.completed self
      | Core_Option_Option_Type.C_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs" 711 4 711 35] Inv1.inv result }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Stub
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Interface
  type i
  predicate into_iter_pre (self : i)
  val into_iter_pre (self : i) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre
  type i
  predicate into_iter_pre (self : i) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 74 20 74 24] true
  val into_iter_pre (self : i) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Stub
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Interface
  type i
  predicate into_iter_post (self : i) (res : i)
  val into_iter_post (self : i) (res : i) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost
  type i
  predicate into_iter_post (self : i) (res : i) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter.rs" 80 8 80 19] self = res
  val into_iter_post (self : i) (res : i) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
  val produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 4 33 29] Inv1.inv result }
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 4 33 29] Inv1.inv (produces_refl a)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = ()
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : () =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 30 4 30 10] ()
  val produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 4 33 29] Inv1.inv result }
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 21 33 22] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 33 4 33 29] Inv1.inv (produces_refl a)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 32 14 32 39] Produces0.produces a (Seq.empty ) a)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Stub
  type idx
  use seq.Seq
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface
  type idx
  use seq.Seq
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
  val produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 4 40 90] Inv2.inv result }
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 4 40 90] Inv2.inv (produces_trans a ab b bc c)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans
  type idx
  use seq.Seq
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq idx
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
   =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 35 4 35 10] ()
  val produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc}
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 4 40 90] Inv2.inv result }
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 37 15 37 32] Produces0.produces a ab b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 38 15 38 32] Produces0.produces b bc c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 22 40 23] Inv0.inv a) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 31 40 33] Inv1.inv ab) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 52 40 53] Inv0.inv b) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 61 40 63] Inv1.inv bc) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 82 40 83] Inv0.inv c) -> ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 40 4 40 90] Inv2.inv (produces_trans a ab b bc c)) && ([#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 39 14 39 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Stub
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Interface
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
  val deep_model (self : usize) : int
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Num_Impl16_DeepModel
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/num.rs" 22 16 22 35] UIntSize.to_int self
  val deep_model (self : usize) : int
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Stub
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Interface
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
  val completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed
  type idx
  use prelude.Borrow
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/iter/range.rs" 14 12 14 78] Resolve0.resolve self /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start ( * self)) >= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end ( * self))
  val completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) : bool
    ensures { result = completed self }
    
end
module Vecmap_Impl2_EntryFromRef_Interface
  type k
  type v
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl2_IsValidKeyrefLg_Stub as IsValidKeyrefLg0 with
    type k = k,
    type v = v
  val entry_from_ref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 4 100 80] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key_hint : Vecmap_KeyRef_Type.t_keyref k) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 98 15 98 48] IsValidKeyrefLg0.is_valid_keyref_lg ( * self) key_hint}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 99 15 99 60] LeLog0.le_log (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key_hint)) (DeepModel0.deep_model key)}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 31 100 35] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 37 100 45] Inv1.inv key_hint}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 58 100 61] Inv2.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 69 100 80] Inv3.inv result }
    
end
module Vecmap_Impl2_EntryFromRef
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv32 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv32.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv31 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv31.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv30 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv30.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv29 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv29.inv,
    predicate Inv1.inv = Inv31.inv,
    predicate Inv2.inv = Inv32.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv28 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = v,
    predicate Inv0.inv = Inv28.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv15.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv15.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv16.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl6_Invariant as Invariant3 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv15.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv16.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl4_Invariant as Invariant2 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv15.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv16.inv
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv27 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv27.inv,
    predicate Inv1.inv = Inv29.inv,
    predicate Inv2.inv = Inv30.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Invariant_Inv_Interface as Inv26 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv26.inv,
    predicate Invariant0.invariant' = Invariant3.invariant',
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv25 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv25.inv,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv24 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv24.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Invariant_Inv_Interface as Inv23 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv23.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate Inv2.inv = Inv28.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = Seq.seq usize
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv1 with
    type t = usize,
    predicate Inv0.inv = Inv22.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv16.inv,
    predicate Inv1.inv = Inv15.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_Invariant as Invariant0 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv20.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Option_Option_Type.t_option usize
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = usize,
    predicate Inv0.inv = Inv19.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = usize,
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    predicate Inv1.inv = Inv23.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv15.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv27.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = bool
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = bool,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared3 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone Vecmap_Entry_Type_Inv as Vecmap_Entry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv25.inv,
    predicate Inv2.inv = Inv26.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv24.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv24.inv,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv24.inv,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv24.inv,
    predicate Inv1.inv = Inv20.inv,
    predicate Inv2.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv24.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv24.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv24.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv24.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv24.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Borrow as TyInv_Borrow1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = k,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = (k, v),
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv23.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range usize)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Core_Ops_Range_Range_Type.t_range usize,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel5
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve3.resolve,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv22.inv,
    predicate Inv2.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface as ProducesRefl0 with
    type idx = usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone Core_Ops_Range_Range_Type_Inv as Core_Ops_Range_Range_Type_Inv0 with
    type idx = usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv1 with
    type k = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone Vecmap_Impl8_DeepModel as DeepModel4 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel3 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Vecmap_Impl8_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Vecmap_Impl11_ToOwned as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel4.deep_model,
    predicate Inv1.inv = Inv2.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, int),
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Vecmap_Impl2_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get0.get
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = k
  clone Core_Cmp_Ord_Cmp_Interface as Cmp0 with
    type self = k,
    predicate Inv0.inv = Inv6.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv20.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv5.inv,
    type Output0.output = (k, v)
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    predicate Inv0.inv = Inv4.inv,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv1.inv = Inv19.inv
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Inv0.inv = Inv3.inv,
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv17.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv18.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl2_IsValidKeyref_Interface as IsValidKeyref0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv0.inv,
    function ToOwned0.to_owned = ToOwned0.to_owned,
    predicate IsValidKeyrefLg0.is_valid_keyref_lg = IsValidKeyrefLg0.is_valid_keyref_lg,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv2.inv = Inv13.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    predicate Inv3.inv = Inv14.inv,
    predicate Inv4.inv = Inv1.inv,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    function DeepModel2.deep_model = DeepModel4.deep_model,
    predicate Inv5.inv = Inv2.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv6.inv = Inv15.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv7.inv = Inv16.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl10_AsRef_Interface as AsRef0 with
    type k = k,
    predicate Inv0.inv = Inv11.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    predicate Inv1.inv = Inv1.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg entry_from_ref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 4 100 80] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key_hint : Vecmap_KeyRef_Type.t_keyref k) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 98 15 98 48] IsValidKeyrefLg0.is_valid_keyref_lg ( * self) key_hint}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 99 15 99 60] LeLog0.le_log (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key_hint)) (DeepModel0.deep_model key)}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 31 100 35] Inv9.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 37 100 45] Inv2.inv key_hint}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 58 100 61] Inv8.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 100 69 100 80] Inv10.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_Entry_Type.t_entry k v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key_hint : Vecmap_KeyRef_Type.t_keyref k = key_hint;
  var key : k = key;
  var _6 : ();
  var _10 : bool;
  var _13 : Vecmap_KeyRef_Type.t_keyref k;
  var _14 : Vecmap_KeyRef_Type.t_keyref k;
  var min_idx : usize;
  var iter : Core_Ops_Range_Range_Type.t_range usize;
  var _22 : usize;
  var iter_old : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var produced : Ghost.ghost_ty (Seq.seq usize);
  var _32 : Core_Option_Option_Type.t_option usize;
  var _33 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _34 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var __creusot_proc_iter_elem : usize;
  var _37 : Ghost.ghost_ty (Seq.seq usize);
  var i : usize;
  var _40 : Core_Cmp_Ordering_Type.t_ordering;
  var _42 : (k, v);
  var _46 : k;
  var _50 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _60 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var i1 : usize;
  var _67 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    switch ([#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs" 218 11 218 41] true)
      | False -> goto BB8
      | True -> goto BB3
      end
  }
  BB3 {
    _14 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 101 44 101 61] AsRef0.as_ref key_hint);
    goto BB4
  }
  BB4 {
    _13 <- _14;
    assert { [@expl:type invariant] Inv0.inv _13 };
    assume { Resolve0.resolve _13 };
    _10 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 101 22 101 62] IsValidKeyref0.is_valid_keyref ( * self) _13);
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] Inv1.inv _14 };
    assume { Resolve1.resolve _14 };
    switch (not _10)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [@expl:type invariant] Inv8.inv key };
    assume { Resolve6.resolve key };
    assert { [@expl:type invariant] Inv2.inv key_hint };
    assume { Resolve2.resolve key_hint };
    assert { [@expl:type invariant] Inv9.inv self };
    assume { Resolve7.resolve self };
    absurd
  }
  BB7 {
    _6 <- ();
    goto BB9
  }
  BB8 {
    _6 <- ();
    goto BB9
  }
  BB9 {
    min_idx <- Vecmap_KeyRef_Type.keyref_min_idx key_hint;
    assert { [@expl:type invariant] Inv2.inv key_hint };
    assume { Resolve2.resolve key_hint };
    _22 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 105 26 105 38] Len0.len (Vecmap_VecMap_Type.vecmap_v ( * self)));
    goto BB10
  }
  BB10 {
    iter <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 8 104 26] IntoIter0.into_iter (Core_Ops_Range_Range_Type.C_Range min_idx _22));
    _22 <- any usize;
    goto BB11
  }
  BB11 {
    iter_old <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 8 104 26] Ghost.new iter);
    goto BB12
  }
  BB12 {
    produced <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 8 104 26] Ghost.new (Seq.empty ));
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 8 104 26] Inv3.inv iter };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 8 104 26] Produces0.produces (Ghost.inner iter_old) (Ghost.inner produced) iter };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 20 104 24] true };
    goto BB15
  }
  BB15 {
    _34 <- Borrow.borrow_mut iter;
    iter <-  ^ _34;
    assume { Inv3.inv ( ^ _34) };
    _33 <- Borrow.borrow_mut ( * _34);
    _34 <- { _34 with current = ( ^ _33) };
    assume { Inv3.inv ( ^ _33) };
    _32 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 8 104 26] Next0.next _33);
    _33 <- any borrowed (Core_Ops_Range_Range_Type.t_range usize);
    goto BB16
  }
  BB16 {
    assert { [@expl:type invariant] Inv4.inv _34 };
    assume { Resolve3.resolve _34 };
    switch (_32)
      | Core_Option_Option_Type.C_None -> goto BB17
      | Core_Option_Option_Type.C_Some _ -> goto BB18
      end
  }
  BB17 {
    i1 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 117 16 117 28] Len0.len (Vecmap_VecMap_Type.vecmap_v ( * self)));
    goto BB35
  }
  BB18 {
    goto BB20
  }
  BB19 {
    assert { [@expl:type invariant] Inv8.inv key };
    assume { Resolve6.resolve key };
    assert { [@expl:type invariant] Inv9.inv self };
    assume { Resolve7.resolve self };
    absurd
  }
  BB20 {
    __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _32;
    _37 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 104 8 104 26] Ghost.new (Seq.(++) (Ghost.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB21
  }
  BB21 {
    produced <- _37;
    _37 <- any Ghost.ghost_ty (Seq.seq usize);
    i <- __creusot_proc_iter_elem;
    _42 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 106 18 106 27] Index0.index (Vecmap_VecMap_Type.vecmap_v ( * self)) i);
    goto BB22
  }
  BB22 {
    assert { [@expl:type invariant] Inv5.inv _42 };
    assume { Resolve4.resolve _42 };
    _46 <- key;
    assert { [@expl:type invariant] Inv6.inv _46 };
    assume { Resolve5.resolve _46 };
    _40 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 106 18 106 39] Cmp0.cmp (let (a, _) = _42 in a) _46);
    goto BB23
  }
  BB23 {
    switch (_40)
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB25
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB26
      | _ -> goto BB24
      end
  }
  BB24 {
    goto BB14
  }
  BB25 {
    goto BB27
  }
  BB26 {
    goto BB30
  }
  BB27 {
    _50 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _50) };
    assume { Inv7.inv ( ^ _50) };
    goto BB28
  }
  BB28 {
    _0 <- Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry _50 key i);
    _50 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB29
  }
  BB29 {
    goto BB39
  }
  BB30 {
    switch (not ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 111 28 111 34] i >= ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 111 33 111 34] (1 : usize))))
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    assert { [@expl:type invariant] Inv8.inv key };
    assume { Resolve6.resolve key };
    assert { [@expl:type invariant] Inv9.inv self };
    assume { Resolve7.resolve self };
    absurd
  }
  BB32 {
    _60 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _60) };
    assume { Inv7.inv ( ^ _60) };
    goto BB33
  }
  BB33 {
    _0 <- Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry _60 key i);
    _60 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB34
  }
  BB34 {
    goto BB39
  }
  BB35 {
    _67 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _67) };
    assume { Inv7.inv ( ^ _67) };
    goto BB36
  }
  BB36 {
    _0 <- Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry _67 key i1);
    _67 <- any borrowed (Vecmap_VecMap_Type.t_vecmap k v);
    key <- any k;
    goto BB37
  }
  BB37 {
    goto BB38
  }
  BB38 {
    goto BB41
  }
  BB39 {
    goto BB40
  }
  BB40 {
    goto BB41
  }
  BB41 {
    assert { [@expl:type invariant] Inv9.inv self };
    assume { Resolve7.resolve self };
    return _0
  }
  
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/model.rs" 101 8 101 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl13_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = borrowed Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 132 27 132 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2685 22 2685 26] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2685 28 2685 33] Inv1.inv index}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 133 26 133 54] HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 134 26 134 57] HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 135 26 135 62] ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 136 26 136 55] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 2685 4 2685 58] Inv2.inv result }
    
end
module Core_Mem_Replace_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  val replace (dest : borrowed t) (src : t) : t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs" 911 24 911 28] Inv0.inv dest}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs" 911 38 911 41] Inv1.inv src}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/mem.rs" 7 22 7 34]  ^ dest = src }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/mem.rs" 8 22 8 37] result =  * dest }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs" 911 0 911 50] Inv1.inv result }
    
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub
  type t
  type a
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Interface
  type t
  type a
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic
  type t
  type a
  use prelude.Int
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ops.rs" 19 8 19 31] Seq.get (ShallowModel0.shallow_model self) ix
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module Alloc_Vec_Impl1_Insert_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = ()
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type a = a
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  val insert (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) (element : t) : ()
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1435 23 1435 27] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1435 29 1435 34] Inv1.inv index}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1435 43 1435 50] Inv2.inv element}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 95 26 95 59] Seq.length (ShallowModel0.shallow_model ( ^ self)) = Seq.length (ShallowModel1.shallow_model self) + 1 }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 96 16 96 89] forall i : int . 0 <= i /\ i < UIntSize.to_int index -> IndexLogic0.index_logic ( ^ self) i = IndexLogic0.index_logic ( * self) i }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 97 26 97 52] IndexLogic0.index_logic ( ^ self) (UIntSize.to_int index) = element }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 98 16 98 105] forall i : int . UIntSize.to_int index < i /\ i < Seq.length (ShallowModel0.shallow_model ( ^ self)) -> IndexLogic0.index_logic ( ^ self) i = IndexLogic0.index_logic ( * self) (i - 1) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1435 4 1435 54] Inv3.inv result }
    
end
module Vecmap_InsertInternal_Interface
  type k
  type v
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use prelude.Int
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv7 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = ()
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_Sorted_Stub as Sorted0 with
    type t = DeepModelTy0.deepModelTy
  clone Vecmap_KeySeqInternal_Stub as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = int
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v)
  val insert_internal [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 0 355 29] (v : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))) (idx : usize) (key : k) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 333 11 333 29] UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model v)}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 25 352 26] Inv0.inv v}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 46 352 49] Inv1.inv idx}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 58 352 61] Inv2.inv key}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 66 352 71] Inv3.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 334 10 334 41] Seq.length (ShallowModel1.shallow_model ( ^ v)) = Seq.length (ShallowModel0.shallow_model v) + 1 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 335 0 335 71] forall i : int . Inv4.inv i -> 0 <= i /\ i < UIntSize.to_int idx -> Seq.get (ShallowModel1.shallow_model ( ^ v)) i = Seq.get (ShallowModel0.shallow_model v) i }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 336 10 336 39] Seq.get (ShallowModel1.shallow_model ( ^ v)) (UIntSize.to_int idx) = (key, value) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 337 0 337 86] forall i : int . Inv4.inv i -> UIntSize.to_int idx < i /\ i < Seq.length (ShallowModel1.shallow_model ( ^ v)) -> Seq.get (ShallowModel1.shallow_model ( ^ v)) i = Seq.get (ShallowModel0.shallow_model v) (i - 1) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 338 0 338 94] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) = 0 -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 339 0 343 2] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) > 0 /\ UIntSize.to_int idx > 0 /\ UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model v) /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 344 0 347 2] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) > 0 /\ UIntSize.to_int idx = 0 /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 348 0 351 2] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) > 0 /\ UIntSize.to_int idx = Seq.length (ShallowModel0.shallow_model v) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 353 0 353 0] Inv5.inv result }
    
end
module Vecmap_InsertInternal
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv15.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv14.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv14.inv,
    predicate Inv2.inv = Inv15.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv12.inv,
    predicate Inv2.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = (k, v)
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq (k, v)
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv10.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = usize,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_Vec_Impl1_Insert_Interface as Insert0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate Inv2.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv3.inv = Inv6.inv,
    predicate Inv4.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv5.inv = Inv8.inv
  let rec cfg insert_internal [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 0 355 29] [@cfg:stackify] [@cfg:subregion_analysis] (v : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))) (idx : usize) (key : k) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 333 11 333 29] UIntSize.to_int idx <= Seq.length (ShallowModel0.shallow_model v)}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 25 352 26] Inv1.inv v}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 46 352 49] Inv2.inv idx}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 58 352 61] Inv3.inv key}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 352 66 352 71] Inv4.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 334 10 334 41] Seq.length (ShallowModel1.shallow_model ( ^ v)) = Seq.length (ShallowModel0.shallow_model v) + 1 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 335 0 335 71] forall i : int . Inv5.inv i -> 0 <= i /\ i < UIntSize.to_int idx -> Seq.get (ShallowModel1.shallow_model ( ^ v)) i = Seq.get (ShallowModel0.shallow_model v) i }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 336 10 336 39] Seq.get (ShallowModel1.shallow_model ( ^ v)) (UIntSize.to_int idx) = (key, value) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 337 0 337 86] forall i : int . Inv5.inv i -> UIntSize.to_int idx < i /\ i < Seq.length (ShallowModel1.shallow_model ( ^ v)) -> Seq.get (ShallowModel1.shallow_model ( ^ v)) i = Seq.get (ShallowModel0.shallow_model v) (i - 1) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 338 0 338 94] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) = 0 -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 339 0 343 2] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) > 0 /\ UIntSize.to_int idx > 0 /\ UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model v) /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 344 0 347 2] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) > 0 /\ UIntSize.to_int idx = 0 /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx) in a)) (DeepModel0.deep_model key) -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 348 0 351 2] Sorted0.sorted (KeySeqInternal0.key_seq_internal ( * v)) /\ Seq.length (ShallowModel0.shallow_model v) > 0 /\ UIntSize.to_int idx = Seq.length (ShallowModel0.shallow_model v) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model v) (UIntSize.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> Sorted0.sorted (KeySeqInternal0.key_seq_internal ( ^ v)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 353 0 353 0] Inv6.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var v : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)) = v;
  var idx : usize = idx;
  var key : k = key;
  var value : v = value;
  var _14 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    _14 <- Borrow.borrow_mut ( * v);
    v <- { v with current = ( ^ _14) };
    assume { Inv0.inv ( ^ _14) };
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    _0 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 357 4 357 31] Insert0.insert _14 idx (key, value));
    _14 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    key <- any k;
    value <- any v;
    goto BB7
  }
  BB7 {
    assert { [@expl:type invariant] Inv1.inv v };
    assume { Resolve0.resolve v };
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 122 8 122 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Vecmap_Impl2_Insert_Interface
  type k
  type v
  use prelude.Int
  use prelude.Borrow
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = int
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  val insert [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 4 154 59] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) (value : v) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 23 154 27] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 29 154 32] Inv1.inv key}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 37 154 42] Inv2.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 152 4 153 86] exists i : int . Inv3.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) /\ Seq.get (KeySeq0.key_seq ( ^ self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i in a) = value }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 50 154 59] Inv4.inv result }
    
end
module Vecmap_Impl2_Insert
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv23 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv23.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv22.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv21.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv20.inv,
    predicate Inv1.inv = Inv22.inv,
    predicate Inv2.inv = Inv23.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv13.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv17.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv16.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv3.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv20.inv,
    predicate Inv2.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone Core_Result_Result_Type_Inv as Core_Result_Result_Type_Inv0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv18.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = usize,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv17.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Option_Option_Type.t_option v
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Borrow as TyInv_Borrow3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Borrow as TyInv_Borrow2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed v
  clone TyInv_Borrow as TyInv_Borrow1 with
    type t = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (k, v)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = (k, v),
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = v,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Vecmap_InsertInternal_Interface as InsertInternal0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv1.inv,
    predicate Inv3.inv = Inv3.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate Inv4.inv = Inv8.inv,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal,
    predicate Sorted0.sorted = Sorted0.sorted,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv5.inv = Inv14.inv,
    predicate Inv6.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv7.inv = Inv13.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve4 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = (k, v)
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv3.inv
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv4.inv,
    type Output0.output = (k, v),
    predicate Inv3.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv13.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone Vecmap_Impl2_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Contains0.contains = Contains0.contains,
    predicate Inv2.inv = Inv11.inv,
    predicate Inv3.inv = Inv8.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv4.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv5.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv6.inv = Inv13.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg insert [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 4 154 59] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) (value : v) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 23 154 27] Inv6.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 29 154 32] Inv1.inv key}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 37 154 42] Inv3.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 152 4 153 86] exists i : int . Inv8.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) /\ Seq.get (KeySeq0.key_seq ( ^ self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i in a) = value }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 154 50 154 59] Inv9.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key : k = key;
  var value : v = value;
  var _5 : Core_Result_Result_Type.t_result usize usize;
  var _8 : k;
  var index : usize;
  var _11 : v;
  var _12 : borrowed v;
  var _13 : borrowed v;
  var _14 : borrowed (k, v);
  var _15 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var index1 : usize;
  var _19 : ();
  var _20 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var _21 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _8 <- key;
    assert { [@expl:type invariant] Inv0.inv _8 };
    assume { Resolve0.resolve _8 };
    _5 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 155 14 155 31] FindK0.find_k ( * self) _8);
    goto BB2
  }
  BB2 {
    switch (_5)
      | Core_Result_Result_Type.C_Ok _ -> goto BB3
      | Core_Result_Result_Type.C_Err _ -> goto BB4
      end
  }
  BB3 {
    goto BB6
  }
  BB4 {
    index1 <- Core_Result_Result_Type.err_0 _5;
    _21 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self));
    self <- { self with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self in Vecmap_VecMap_Type.C_VecMap ( ^ _21)) };
    assume { Inv2.inv ( ^ _21) };
    _20 <- Borrow.borrow_mut ( * _21);
    _21 <- { _21 with current = ( ^ _20) };
    assume { Inv2.inv ( ^ _20) };
    _19 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 158 16 158 63] InsertInternal0.insert_internal _20 index1 key value);
    _20 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    key <- any k;
    value <- any v;
    goto BB10
  }
  BB5 {
    assert { [@expl:type invariant] Inv3.inv value };
    assume { Resolve6.resolve value };
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    absurd
  }
  BB6 {
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    index <- Core_Result_Result_Type.ok_0 _5;
    _15 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self));
    self <- { self with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self in Vecmap_VecMap_Type.C_VecMap ( ^ _15)) };
    assume { Inv2.inv ( ^ _15) };
    _14 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 156 53 156 66] IndexMut0.index_mut _15 index);
    _15 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB7
  }
  BB7 {
    _13 <- Borrow.borrow_mut (let (_, a) =  * _14 in a);
    _14 <- { _14 with current = (let (a, b) =  * _14 in (a,  ^ _13)) };
    assume { Inv3.inv ( ^ _13) };
    _12 <- Borrow.borrow_mut ( * _13);
    _13 <- { _13 with current = ( ^ _12) };
    assume { Inv3.inv ( ^ _12) };
    _11 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 156 30 156 76] Replace0.replace _12 value);
    _12 <- any borrowed v;
    value <- any v;
    goto BB8
  }
  BB8 {
    assert { [@expl:type invariant] Inv4.inv _14 };
    assume { Resolve2.resolve _14 };
    assert { [@expl:type invariant] Inv5.inv _13 };
    assume { Resolve3.resolve _13 };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    _0 <- Core_Option_Option_Type.C_Some _11;
    _11 <- any v;
    goto BB9
  }
  BB9 {
    goto BB11
  }
  BB10 {
    assert { [@expl:type invariant] Inv7.inv _21 };
    assume { Resolve5.resolve _21 };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/resolve.rs" 16 8 16 60] Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module Alloc_Vec_Impl1_Remove_Interface
  type t
  type a
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use seq_ext.SeqExt
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type a = a
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val remove (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) : t
    requires {[#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 89 27 89 44] UIntSize.to_int index < Seq.length (ShallowModel0.shallow_model self)}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1496 23 1496 27] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1496 29 1496 34] Inv1.inv index}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 90 26 90 45] result = IndexLogic0.index_logic ( * self) (UIntSize.to_int index) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 91 26 91 111] ShallowModel1.shallow_model ( ^ self) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model self) 0 (UIntSize.to_int index)) (SeqExt.subsequence (ShallowModel0.shallow_model self) (UIntSize.to_int index + 1) (Seq.length (ShallowModel0.shallow_model self))) }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/vec.rs" 92 26 92 59] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) - 1 }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs" 1496 4 1496 47] Inv2.inv result }
    
end
module Vecmap_Impl2_Remove_Interface
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use seq_ext.SeqExt
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = int
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  val remove [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 4 175 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 23 175 27] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 29 175 32] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 166 4 168 30] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq ( * self)) (DeepModel0.deep_model key) /\  * self =  ^ self }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 169 4 174 17] forall v : v . Inv2.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . Inv3.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ Seq.get (KeySeq0.key_seq ( * self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i in a) = v /\ ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self)) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) 0 i) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i + 1) (Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 41 175 50] Inv4.inv result }
    
end
module Vecmap_Impl2_Remove
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq_ext.SeqExt
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv21.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv20.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv19.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv20.inv,
    predicate Inv2.inv = Inv21.inv,
    axiom .
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv14.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv18.inv,
    predicate Inv2.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Borrow as TyInv_Borrow1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = (k, v)
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone Core_Result_Result_Type_Inv as Core_Result_Result_Type_Inv0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv17.inv,
    predicate Inv2.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option v
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = v,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = k
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv12.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (Vecmap_VecMap_Type.t_vecmap k v)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv10.inv
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve2 with
    type t1 = k,
    type t2 = v,
    predicate Resolve0.resolve = Resolve3.resolve,
    predicate Resolve1.resolve = Resolve4.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Alloc_Vec_Impl1_Remove_Interface as Remove0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv8.inv,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv3.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv10.inv
  clone Vecmap_Impl2_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    predicate Inv2.inv = Inv8.inv,
    predicate Inv3.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv4.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv5.inv = Inv1.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv6.inv = Inv10.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg remove [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 4 175 50] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 23 175 27] Inv2.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 29 175 32] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 166 4 168 30] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq ( * self)) (DeepModel0.deep_model key) /\  * self =  ^ self }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 169 4 174 17] forall v : v . Inv4.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . Inv5.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ Seq.get (KeySeq0.key_seq ( * self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i in a) = v /\ ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self)) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) 0 i) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i + 1) (Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 175 41 175 50] Inv6.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self : borrowed (Vecmap_VecMap_Type.t_vecmap k v) = self;
  var key : k = key;
  var _5 : Core_Result_Result_Type.t_result usize usize;
  var index : usize;
  var _11 : (k, v);
  var _12 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    _5 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 176 14 176 30] FindK0.find_k ( * self) key);
    goto BB1
  }
  BB1 {
    switch (_5)
      | Core_Result_Result_Type.C_Ok _ -> goto BB2
      | Core_Result_Result_Type.C_Err _ -> goto BB3
      end
  }
  BB2 {
    goto BB5
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB9
  }
  BB4 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB5 {
    index <- Core_Result_Result_Type.ok_0 _5;
    _12 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self));
    self <- { self with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self in Vecmap_VecMap_Type.C_VecMap ( ^ _12)) };
    assume { Inv1.inv ( ^ _12) };
    _11 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 177 30 177 50] Remove0.remove _12 index);
    _12 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB6
  }
  BB6 {
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    assert { [@expl:type invariant] Inv3.inv _11 };
    assume { Resolve2.resolve _11 };
    _0 <- Core_Option_Option_Type.C_Some (let (_, a) = _11 in a);
    _11 <- (let (a, b) = _11 in (a, any v));
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Vecmap_Impl2_Get_Interface
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = int
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val get [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 4 187 44] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 16 187 20] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 22 187 25] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 183 4 183 77] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 184 4 186 77] forall v : v . Inv2.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . Inv3.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = v) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 34 187 44] Inv4.inv result }
    
end
module Vecmap_Impl2_Get
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv22.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv20.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv19.inv,
    predicate Inv1.inv = Inv21.inv,
    predicate Inv2.inv = Inv22.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv18.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv20.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = v,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv12.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv18.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone Core_Result_Result_Type_Inv as Core_Result_Result_Type_Inv0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv17.inv,
    predicate Inv2.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv15.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Option_Option_Type.t_option v
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared3 with
    type t = v,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl2_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    predicate Inv2.inv = Inv6.inv,
    predicate Inv3.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv4.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv5.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv6.inv = Inv9.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg get [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 4 187 44] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 16 187 20] Inv1.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 22 187 25] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 183 4 183 77] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 184 4 186 77] forall v : v . Inv3.inv v -> result = Core_Option_Option_Type.C_Some v -> (exists i : int . Inv4.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = v) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 187 34 187 44] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : k = key;
  var _5 : Core_Result_Result_Type.t_result usize usize;
  var index : usize;
  var _11 : v;
  var _12 : (k, v);
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv key };
    assume { Resolve0.resolve key };
    _5 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 188 14 188 30] FindK0.find_k self key);
    goto BB1
  }
  BB1 {
    switch (_5)
      | Core_Result_Result_Type.C_Ok _ -> goto BB2
      | Core_Result_Result_Type.C_Err _ -> goto BB3
      end
  }
  BB2 {
    goto BB5
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB7
  }
  BB4 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    absurd
  }
  BB5 {
    index <- Core_Result_Result_Type.ok_0 _5;
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _12 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 189 31 189 44] Index0.index (Vecmap_VecMap_Type.vecmap_v self) index);
    goto BB6
  }
  BB6 {
    _11 <- (let (_, a) = _12 in a);
    assert { [@expl:type invariant] Inv2.inv _12 };
    assume { Resolve2.resolve _12 };
    assert { [@expl:type invariant] Inv3.inv _11 };
    assume { Resolve3.resolve _11 };
    _0 <- Core_Option_Option_Type.C_Some _11;
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Core_Result_Impl0_IsOk_Interface
  type t
  type e
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = bool
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Result_Result_Type.t_result t e
  val is_ok (self : Core_Result_Result_Type.t_result t e) : bool
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs" 538 24 538 28] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/result.rs" 22 26 22 63] result = (exists t : t . Inv1.inv t /\ self = Core_Result_Result_Type.C_Ok t) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs" 538 4 538 37] Inv2.inv result }
    
end
module Vecmap_Impl2_ContainsKey_Interface
  type k
  type v
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = bool
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val contains_key [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 4 196 47] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : bool
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 25 196 29] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 31 196 34] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 195 14 195 65] result = Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 43 196 47] Inv2.inv result }
    
end
module Vecmap_Impl2_ContainsKey
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv20.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = v,
    predicate Inv0.inv = Inv18.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv17.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv20.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv10.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv16.inv,
    predicate Inv2.inv = Inv17.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Result_Result_Type.t_result usize usize
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = Core_Result_Result_Type.t_result usize usize,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv6.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = usize
  clone Core_Result_Result_Type_Inv as Core_Result_Result_Type_Inv0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv13.inv,
    predicate Inv2.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = bool
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = bool,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Core_Result_Impl0_IsOk_Interface as IsOk0 with
    type t = usize,
    type e = usize,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv2.inv
  clone Vecmap_Impl2_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv3.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv4.inv = Inv5.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv5.inv = Inv6.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv6.inv = Inv7.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg contains_key [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 4 196 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : bool
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 25 196 29] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 31 196 34] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 195 14 195 65] result = Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 196 43 196 47] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : k = key;
  var _5 : Core_Result_Result_Type.t_result usize usize;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    _5 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 197 8 197 24] FindK0.find_k self key);
    goto BB1
  }
  BB1 {
    _0 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 197 8 197 32] IsOk0.is_ok _5);
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Core_Cmp_PartialOrd_Gt_Interface
  type self
  type rhs
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = bool
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel1 with
    type t = rhs,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = rhs
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  val gt (self : self) (other : rhs) : bool
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1100 11 1100 15] Inv0.inv self}
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1100 17 1100 22] Inv1.inv other}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/cmp.rs" 33 26 33 76] result = GtLog0.gt_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs" 1100 4 1100 37] Inv2.inv result }
    
end
module Vecmap_Impl2_NextMapping_Interface
  type k
  type v
  use prelude.Int
  use seq.Seq
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use prelude.Int
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv5.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = int
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val next_mapping [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 4 213 75] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 25 213 29] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 31 213 34] Inv1.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 202 4 204 57] result = Core_Option_Option_Type.C_None -> (forall i : int . Inv2.inv i -> i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 205 4 212 57] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv3.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (exists i : int . Inv2.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)) /\ GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = (let (_, a) = entry in a) /\ (forall j : int . Inv2.inv j -> j >= 0 /\ j < i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a))) /\ LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 51 213 75] Inv4.inv result }
    
end
module Vecmap_Impl2_NextMapping
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv30 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv30.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv29 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv29.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv28 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv28.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv27 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv27.inv,
    predicate Inv1.inv = Inv29.inv,
    predicate Inv2.inv = Inv30.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel4 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel4.deep_model,
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv14.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv26 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv26.inv,
    predicate Inv1.inv = Inv27.inv,
    predicate Inv2.inv = Inv28.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv25 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = v,
    predicate Inv0.inv = Inv25.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv24 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = k,
    predicate Inv0.inv = Inv24.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv23 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv23.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple21 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv22.inv,
    predicate Inv1.inv = Inv24.inv,
    predicate Inv2.inv = Inv25.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv20.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Seq.seq usize
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv1 with
    type t = usize,
    predicate Inv0.inv = Inv19.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Core_Option_Option_Type.t_option usize
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv1 with
    type t = usize,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared5 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv22.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv13.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv26.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv1 with
    type k = k,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv24.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = bool
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = bool,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = Vecmap_KeyRef_Type.t_keyref k,
    type t1 = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared4 with
    type t = v,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv25.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared3 with
    type t = k,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv24.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv23.inv,
    axiom .
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = (k, v),
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv22.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (Core_Ops_Range_Range_Type.t_range usize)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Core_Ops_Range_Range_Type.t_range usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel3
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve1.resolve,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv20.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv20.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv20.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv20.inv,
    predicate Inv1.inv = Inv21.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv20.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv20.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv20.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv20.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv20.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface as ProducesRefl0 with
    type idx = usize,
    predicate Inv0.inv = Inv1.inv,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone Core_Ops_Range_Range_Type_Inv as Core_Ops_Range_Range_Type_Inv0 with
    type idx = usize,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Vecmap_Impl8_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Vecmap_Impl8_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Vecmap_Impl2_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get0.get
  clone Vecmap_Impl11_ToOwned as ToOwned0 with
    type k = k,
    predicate Inv0.inv = Inv5.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    predicate Inv1.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Core_Cmp_PartialOrd_Gt_Interface as Gt0 with
    type self = k,
    type rhs = k,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv7.inv,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    predicate Inv2.inv = Inv11.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (k, v)
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv15.inv,
    predicate Inv1.inv = Inv16.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv4.inv,
    type Output0.output = (k, v)
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    predicate Inv0.inv = Inv3.inv,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces,
    predicate Inv1.inv = Inv17.inv
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Inv0.inv = Inv1.inv,
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv15.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv16.inv
  clone Vecmap_Impl2_IsValidKeyref_Interface as IsValidKeyref0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv0.inv,
    function ToOwned0.to_owned = ToOwned0.to_owned,
    predicate IsValidKeyrefLg0.is_valid_keyref_lg = IsValidKeyrefLg0.is_valid_keyref_lg,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv2.inv = Inv2.inv,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function LeLog0.le_log = LeLog0.le_log,
    predicate Inv3.inv = Inv11.inv,
    predicate Inv4.inv = Inv5.inv,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    function DeepModel2.deep_model = DeepModel2.deep_model,
    predicate Inv5.inv = Inv12.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    predicate Inv6.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv7.inv = Inv14.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg next_mapping [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 4 213 75] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 25 213 29] Inv6.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 31 213 34] Inv5.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 202 4 204 57] result = Core_Option_Option_Type.C_None -> (forall i : int . Inv2.inv i -> i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 205 4 212 57] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv9.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (exists i : int . Inv2.inv i /\ i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)) /\ GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = (let (_, a) = entry in a) /\ (forall j : int . Inv2.inv j -> j >= 0 /\ j < i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a))) /\ LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 213 51 213 75] Inv10.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var key : Vecmap_KeyRef_Type.t_keyref k = key;
  var from : usize;
  var _6 : bool;
  var _9 : Vecmap_KeyRef_Type.t_keyref k;
  var iter : Core_Ops_Range_Range_Type.t_range usize;
  var _14 : usize;
  var iter_old : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var produced : Ghost.ghost_ty (Seq.seq usize);
  var _24 : Core_Option_Option_Type.t_option usize;
  var _25 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _26 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var __creusot_proc_iter_elem : usize;
  var _29 : Ghost.ghost_ty (Seq.seq usize);
  var idx : usize;
  var _32 : bool;
  var _34 : (k, v);
  var key1 : k;
  var value : v;
  var _41 : (k, v);
  var _42 : (k, v);
  {
    goto BB0
  }
  BB0 {
    _9 <- key;
    assert { [@expl:type invariant] Inv0.inv _9 };
    assume { Resolve0.resolve _9 };
    _6 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 214 22 214 48] IsValidKeyref0.is_valid_keyref self _9);
    goto BB1
  }
  BB1 {
    switch (_6)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    from <- Vecmap_KeyRef_Type.keyref_min_idx key;
    goto BB4
  }
  BB3 {
    from <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 217 12 217 13] (0 : usize));
    goto BB4
  }
  BB4 {
    _14 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 222 25 222 37] Len0.len (Vecmap_VecMap_Type.vecmap_v self));
    goto BB5
  }
  BB5 {
    iter <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] IntoIter0.into_iter (Core_Ops_Range_Range_Type.C_Range from _14));
    _14 <- any usize;
    goto BB6
  }
  BB6 {
    iter_old <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] Ghost.new iter);
    goto BB7
  }
  BB7 {
    produced <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] Ghost.new (Seq.empty ));
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] Inv1.inv iter };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] Produces0.produces (Ghost.inner iter_old) (Ghost.inner produced) iter };
    invariant { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] forall j : int . Inv2.inv j -> j >= 0 /\ j < Seq.length (Ghost.inner produced) + UIntSize.to_int from -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) };
    goto BB10
  }
  BB10 {
    _26 <- Borrow.borrow_mut iter;
    iter <-  ^ _26;
    assume { Inv1.inv ( ^ _26) };
    _25 <- Borrow.borrow_mut ( * _26);
    _26 <- { _26 with current = ( ^ _25) };
    assume { Inv1.inv ( ^ _25) };
    _24 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] Next0.next _25);
    _25 <- any borrowed (Core_Ops_Range_Range_Type.t_range usize);
    goto BB11
  }
  BB11 {
    assert { [@expl:type invariant] Inv3.inv _26 };
    assume { Resolve1.resolve _26 };
    switch (_24)
      | Core_Option_Option_Type.C_None -> goto BB12
      | Core_Option_Option_Type.C_Some _ -> goto BB13
      end
  }
  BB12 {
    assert { [@expl:type invariant] Inv5.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB22
  }
  BB13 {
    goto BB15
  }
  BB14 {
    assert { [@expl:type invariant] Inv5.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    absurd
  }
  BB15 {
    __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _24;
    _29 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 220 8 221 63] Ghost.new (Seq.(++) (Ghost.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB16
  }
  BB16 {
    produced <- _29;
    _29 <- any Ghost.ghost_ty (Seq.seq usize);
    idx <- __creusot_proc_iter_elem;
    _34 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 223 15 223 26] Index0.index (Vecmap_VecMap_Type.vecmap_v self) idx);
    goto BB17
  }
  BB17 {
    assert { [@expl:type invariant] Inv4.inv _34 };
    assume { Resolve2.resolve _34 };
    _32 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 223 15 223 39] Gt0.gt (let (a, _) = _34 in a) (Vecmap_KeyRef_Type.keyref_key key));
    goto BB18
  }
  BB18 {
    switch (_32)
      | False -> goto BB21
      | True -> goto BB19
      end
  }
  BB19 {
    assert { [@expl:type invariant] Inv5.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv6.inv self };
    assume { Resolve4.resolve self };
    _42 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 224 36 224 47] Index0.index (Vecmap_VecMap_Type.vecmap_v self) idx);
    goto BB20
  }
  BB20 {
    _41 <- _42;
    assert { [@expl:type invariant] Inv4.inv _42 };
    assume { Resolve2.resolve _42 };
    key1 <- (let (a, _) = _41 in a);
    value <- (let (_, a) = _41 in a);
    assert { [@expl:type invariant] Inv4.inv _41 };
    assume { Resolve2.resolve _41 };
    assert { [@expl:type invariant] Inv7.inv key1 };
    assume { Resolve5.resolve key1 };
    assert { [@expl:type invariant] Inv8.inv value };
    assume { Resolve6.resolve value };
    _0 <- Core_Option_Option_Type.C_Some (Vecmap_KeyRef_Type.C_KeyRef key1 idx, value);
    goto BB22
  }
  BB21 {
    goto BB9
  }
  BB22 {
    return _0
  }
  
end
module CreusotContracts_Logic_Ops_Impl2_IndexLogic_Stub
  type t
  use prelude.Slice
  use prelude.Int
  function index_logic [@inline:trivial] (self : slice t) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl2_IndexLogic_Interface
  type t
  use prelude.Slice
  use prelude.Int
  function index_logic [@inline:trivial] (self : slice t) (ix : int) : t
  val index_logic [@inline:trivial] (self : slice t) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl2_IndexLogic
  type t
  use prelude.Slice
  use prelude.Int
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  function index_logic [@inline:trivial] (self : slice t) (ix : int) : t =
    [#"/mnt/data/projects/creusot/creusot-contracts/src/logic/ops.rs" 41 8 41 31] Seq.get (ShallowModel0.shallow_model self) ix
  val index_logic [@inline:trivial] (self : slice t) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module Core_Slice_Impl0_First_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Option_Option_Type.t_option t
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic_Stub as IndexLogic0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val first (self : slice t) : Core_Option_Option_Type.t_option t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 176 24 176 28] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 291 8 291 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 292 8 292 69] forall x : t . Inv1.inv x -> result = Core_Option_Option_Type.C_Some x -> IndexLogic0.index_logic self 0 = x }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 176 4 176 43] Inv2.inv result }
    
end
module Vecmap_Impl2_MinEntry_Interface
  type k
  type v
  use seq.Seq
  use prelude.Borrow
  use prelude.UIntSize
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = int
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val min_entry [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 261 4 261 55] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 261 22 261 26] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 255 4 255 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 256 4 256 101] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv1.inv entry -> result = Core_Option_Option_Type.C_Some entry -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) 0 = (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a), let (_, a) = entry in a) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 257 4 257 80] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv1.inv entry -> result = Core_Option_Option_Type.C_Some entry -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = entry in a)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 258 4 260 6] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv1.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (forall i : int . Inv2.inv i -> i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 261 31 261 55] Inv3.inv result }
    
end
module Vecmap_Impl2_MinEntry
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv25 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv25.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv24 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv24.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv23 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv23.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv22.inv,
    predicate Inv1.inv = Inv24.inv,
    predicate Inv2.inv = Inv25.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv21.inv,
    predicate Inv1.inv = Inv22.inv,
    predicate Inv2.inv = Inv23.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple21 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv20.inv,
    predicate Inv1.inv = Inv14.inv,
    predicate Inv2.inv = Inv15.inv,
    axiom .
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv16.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX'
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = v,
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = slice (k, v)
  clone TyInv_Slice as TyInv_Slice0 with
    type t = (k, v),
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv20.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv12.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv20.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv10.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv21.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared5 with
    type t = (k, v),
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv20.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel3 with
    type t = (k, v),
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v)
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv1 with
    type t = (Vecmap_KeyRef_Type.t_keyref k, v),
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = v
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = Vecmap_KeyRef_Type.t_keyref k,
    type t1 = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv16.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared3 with
    type t = v,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option (k, v)
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic as IndexLogic0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate Inv0.inv = Inv13.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv11.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = slice (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = slice (k, v),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_First_Interface as First0 with
    type t = (k, v),
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv9.inv,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv2.inv = Inv2.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = slice (k, v)
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    predicate Inv1.inv = Inv1.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg min_entry [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 261 4 261 55] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 261 22 261 26] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 255 4 255 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 256 4 256 101] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv5.inv entry -> result = Core_Option_Option_Type.C_Some entry -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) 0 = (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a), let (_, a) = entry in a) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 257 4 257 80] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv5.inv entry -> result = Core_Option_Option_Type.C_Some entry -> UIntSize.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = entry in a)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 258 4 260 6] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . Inv5.inv entry -> result = Core_Option_Option_Type.C_Some entry -> (forall i : int . Inv6.inv i -> i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)))) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 261 31 261 55] Inv7.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var _6 : Core_Option_Option_Type.t_option (k, v);
  var _8 : slice (k, v);
  var key : k;
  var value : v;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _8 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 262 14 262 28] Deref0.deref (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv _8 };
    assume { Resolve1.resolve _8 };
    _6 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 262 14 262 28] First0.first _8);
    goto BB2
  }
  BB2 {
    switch (_6)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv _6 };
    assume { Resolve2.resolve _6 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB7
  }
  BB4 {
    goto BB6
  }
  BB5 {
    assert { [@expl:type invariant] Inv2.inv _6 };
    assume { Resolve2.resolve _6 };
    absurd
  }
  BB6 {
    key <- (let (a, _) = Core_Option_Option_Type.some_0 _6 in a);
    value <- (let (_, a) = Core_Option_Option_Type.some_0 _6 in a);
    assert { [@expl:type invariant] Inv2.inv _6 };
    assume { Resolve2.resolve _6 };
    assert { [@expl:type invariant] Inv3.inv key };
    assume { Resolve3.resolve key };
    assert { [@expl:type invariant] Inv4.inv value };
    assume { Resolve4.resolve value };
    _0 <- Core_Option_Option_Type.C_Some (Vecmap_KeyRef_Type.C_KeyRef key ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 263 63 263 64] (0 : usize)), value);
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Core_Slice_Impl0_Last_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use prelude.Slice
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Option_Option_Type.t_option t
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic_Stub as IndexLogic0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val last (self : slice t) : Core_Option_Option_Type.t_option t
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 299 23 299 27] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 287 8 287 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/slice.rs" 288 8 288 83] forall x : t . Inv1.inv x -> result = Core_Option_Option_Type.C_Some x -> IndexLogic0.index_logic self (Seq.length (ShallowModel0.shallow_model self) - 1) = x }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs" 299 4 299 42] Inv2.inv result }
    
end
module Vecmap_Impl2_MaxKey_Interface
  type k
  type v
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = int
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  val max_key [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 274 4 274 39] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 274 20 274 24] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 269 4 269 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 270 4 273 6] forall k : k . Inv1.inv k -> result = Core_Option_Option_Type.C_Some k -> (forall i : int . Inv2.inv i -> i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model k)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 274 29 274 39] Inv3.inv result }
    
end
module Vecmap_Impl2_MaxKey
  type k
  type v
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use prelude.Int
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv22 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv22.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv21 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv21.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv20 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv20.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv19.inv,
    predicate Inv1.inv = Inv21.inv,
    predicate Inv2.inv = Inv22.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = v,
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv20.inv,
    axiom .
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv13.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = slice (k, v)
  clone TyInv_Slice as TyInv_Slice0 with
    type t = (k, v),
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel3 with
    type t = (k, v),
    predicate Inv0.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option k
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv1 with
    type t = k,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv16.inv,
    predicate Inv2.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv14.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv15.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared3 with
    type t = k,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = (k, v),
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option (k, v)
  clone Core_Option_Option_Type_Inv as Core_Option_Option_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl2_IndexLogic as IndexLogic0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate Inv0.inv = Inv11.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = slice (k, v)
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = slice (k, v),
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = slice (k, v),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_Last_Interface as Last0 with
    type t = (k, v),
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv3.inv,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv2.inv = Inv2.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = slice (k, v)
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    predicate Inv1.inv = Inv1.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg max_key [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 274 4 274 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 274 20 274 24] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 269 4 269 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 270 4 273 6] forall k : k . Inv4.inv k -> result = Core_Option_Option_Type.C_Some k -> (forall i : int . Inv5.inv i -> i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model k)) }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 274 29 274 39] Inv6.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option k;
  var self : Vecmap_VecMap_Type.t_vecmap k v = self;
  var _4 : Core_Option_Option_Type.t_option (k, v);
  var _6 : slice (k, v);
  var e : (k, v);
  var _11 : k;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _6 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 275 14 275 27] Deref0.deref (Vecmap_VecMap_Type.vecmap_v self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv _6 };
    assume { Resolve1.resolve _6 };
    _4 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 275 14 275 27] Last0.last _6);
    goto BB2
  }
  BB2 {
    switch (_4)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv2.inv _4 };
    assume { Resolve2.resolve _4 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB7
  }
  BB4 {
    goto BB6
  }
  BB5 {
    assert { [@expl:type invariant] Inv2.inv _4 };
    assume { Resolve2.resolve _4 };
    absurd
  }
  BB6 {
    e <- Core_Option_Option_Type.some_0 _4;
    assert { [@expl:type invariant] Inv2.inv _4 };
    assume { Resolve2.resolve _4 };
    _11 <- (let (a, _) = e in a);
    assert { [@expl:type invariant] Inv3.inv e };
    assume { Resolve3.resolve e };
    assert { [@expl:type invariant] Inv4.inv _11 };
    assume { Resolve4.resolve _11 };
    _0 <- Core_Option_Option_Type.C_Some _11;
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Vecmap_Impl3_Keyref_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_Entry_Type.t_entry k v
  val keyref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 411 4 411 38] (self : Vecmap_Entry_Type.t_entry k v) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 411 19 411 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 411 28 411 38] Inv1.inv result }
    
end
module Vecmap_Impl3_Keyref
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    axiom .
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = v,
    predicate Inv0.inv = Inv14.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv15.inv,
    predicate Inv2.inv = Inv16.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv14.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv12.inv,
    predicate Inv2.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Seq.seq (k, v)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant3 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant2 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    predicate Invariant0.invariant' = Invariant3.invariant',
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv7.inv,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl6_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl4_Invariant as Invariant0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv9.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv6.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv5.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone Vecmap_Entry_Type_Inv as Vecmap_Entry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv6.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_Entry_Type.t_entry k v
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_Entry_Type.t_entry k v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_Entry_Type.t_entry k v
  let rec cfg keyref [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 411 4 411 38] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_Entry_Type.t_entry k v) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 411 19 411 23] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 411 28 411 38] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_Entry_Type.t_entry k v = self;
  var key : k;
  var index : usize;
  var key1 : k;
  var index1 : usize;
  {
    goto BB0
  }
  BB0 {
    switch (self)
      | Vecmap_Entry_Type.C_Vacant _ -> goto BB1
      | Vecmap_Entry_Type.C_Occupied _ -> goto BB2
      end
  }
  BB1 {
    goto BB4
  }
  BB2 {
    key1 <- Vecmap_OccupiedEntry_Type.occupiedentry_key (Vecmap_Entry_Type.occupied_0 self);
    index1 <- Vecmap_OccupiedEntry_Type.occupiedentry_index (Vecmap_Entry_Type.occupied_0 self);
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv key1 };
    assume { Resolve1.resolve key1 };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef key1 index1;
    goto BB5
  }
  BB3 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    absurd
  }
  BB4 {
    key <- Vecmap_VacantEntry_Type.vacantentry_key (Vecmap_Entry_Type.vacant_0 self);
    index <- Vecmap_VacantEntry_Type.vacantentry_index (Vecmap_Entry_Type.vacant_0 self);
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:type invariant] Inv1.inv key };
    assume { Resolve1.resolve key };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef key index;
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Vecmap_Impl13_Resolve_Stub
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 427 4 427 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
end
module Vecmap_Impl13_Resolve_Interface
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 427 4 427 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
  val resolve [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 427 4 427 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = resolve self }
    
end
module Vecmap_Impl13_Resolve
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 427 4 427 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
    
   =
    [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 425 4 425 16] Resolve0.resolve (Vecmap_VacantEntry_Type.vacantentry_map self) /\ Resolve1.resolve (Vecmap_VacantEntry_Type.vacantentry_key self)
  val resolve [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 427 4 427 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = resolve self }
    
end
module Vecmap_Impl5_Insert_Interface
  type k
  type v
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = ()
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv4.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv5.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = int
  val insert [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 4 456 33] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 452 4 453 62] forall i : int . Inv0.inv i -> i >= 0 /\ i < UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 454 4 455 62] forall i : int . Inv0.inv i -> i >= UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self))) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 18 456 22] Inv1.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 24 456 29] Inv2.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 34 456 34] Inv3.inv result }
    
end
module Vecmap_Impl5_Insert
  type k
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv17.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv15.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv14.inv,
    predicate Inv1.inv = Inv16.inv,
    predicate Inv2.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant2 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Inv1.inv = Inv0.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv14.inv,
    predicate Inv2.inv = Inv15.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv13.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = v,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv12.inv,
    predicate Inv2.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv11.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = int
  clone CreusotContracts_Logic_Int_Int_Type_Inv as CreusotContracts_Logic_Int_Int_Type_Inv0 with
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl4_Invariant as Invariant0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv8.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_VacantEntry_Type.t_vacantentry k v
  clone Vecmap_VacantEntry_Type_Inv as Vecmap_VacantEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv2.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv10.inv,
    predicate Inv2.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone Vecmap_Impl13_Resolve as Resolve1 with
    type k = k,
    type v = v,
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Vecmap_InsertInternal_Interface as InsertInternal0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate Inv2.inv = Inv7.inv,
    predicate Inv3.inv = Inv4.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate Inv4.inv = Inv3.inv,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal,
    predicate Sorted0.sorted = Sorted0.sorted,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function GtLog0.gt_log = GtLog0.gt_log,
    function LtLog0.lt_log = LtLog0.lt_log,
    predicate Inv5.inv = Inv5.inv,
    predicate Inv6.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv7.inv = Inv8.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg insert [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 4 456 33] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 452 4 453 62] forall i : int . Inv3.inv i -> i >= 0 /\ i < UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 454 4 455 62] forall i : int . Inv3.inv i -> i >= UIntSize.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self))) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 18 456 22] Inv2.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 24 456 29] Inv4.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 456 34 456 34] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : Vecmap_VacantEntry_Type.t_vacantentry k v = self;
  var value : v = value;
  var _5 : ();
  var _6 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var _7 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    _7 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self));
    self <- (let Vecmap_VacantEntry_Type.C_VacantEntry a b c = self in Vecmap_VacantEntry_Type.C_VacantEntry ({ (Vecmap_VacantEntry_Type.vacantentry_map self) with current = (let Vecmap_VecMap_Type.C_VecMap a =  * Vecmap_VacantEntry_Type.vacantentry_map self in Vecmap_VecMap_Type.C_VecMap ( ^ _7)) }) b c);
    assume { Inv0.inv ( ^ _7) };
    _6 <- Borrow.borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _6) };
    assume { Inv0.inv ( ^ _6) };
    _5 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 457 8 457 69] InsertInternal0.insert_internal _6 (Vecmap_VacantEntry_Type.vacantentry_index self) (Vecmap_VacantEntry_Type.vacantentry_key self) value);
    _6 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    self <- (let Vecmap_VacantEntry_Type.C_VacantEntry a b c = self in Vecmap_VacantEntry_Type.C_VacantEntry a (any k) c);
    value <- any v;
    goto BB3
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv _7 };
    assume { Resolve0.resolve _7 };
    assert { [@expl:type invariant] Inv2.inv self };
    assume { Resolve1.resolve self };
    assert { [@expl:assertion] [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 458 22 458 38] Invariant0.invariant' self };
    goto BB4
  }
  BB4 {
    _0 <- ();
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Vecmap_Impl7_Replace_Interface
  type k
  type v
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = ()
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  val replace [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 4 484 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 24 484 28] Inv0.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 30 484 35] Inv1.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 483 14 483 54] (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( ^ self)))) (UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self))) in a) = value }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 40 484 40] Inv2.inv result }
    
end
module Vecmap_Impl7_Replace
  type k
  type v
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = ()
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv15.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant2 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv14.inv,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv15.inv,
    predicate Inv2.inv = Inv16.inv,
    axiom .
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl6_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv14.inv,
    predicate Inv2.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv13.inv,
    predicate Inv2.inv = Inv1.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Borrow as TyInv_Borrow2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  clone TyInv_Borrow as TyInv_Borrow1 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (k, v)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = v
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v),
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv7.inv
  let rec cfg replace [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 4 484 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) (value : v) : ()
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 24 484 28] Inv3.inv self}
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 30 484 35] Inv1.inv value}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 483 14 483 54] (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( ^ self)))) (UIntSize.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self))) in a) = value }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 484 40 484 40] Inv4.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v) = self;
  var value : v = value;
  var _5 : borrowed (k, v);
  var _6 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _6 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)));
    self <- { self with current = (let Vecmap_OccupiedEntry_Type.C_OccupiedEntry a b c =  * self in Vecmap_OccupiedEntry_Type.C_OccupiedEntry ({ (Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)) with current = (let Vecmap_VecMap_Type.C_VecMap a =  * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self) in Vecmap_VecMap_Type.C_VecMap ( ^ _6)) }) b c) };
    assume { Inv0.inv ( ^ _6) };
    _5 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 485 8 485 30] IndexMut0.index_mut _6 (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self)));
    _6 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _5 <- { _5 with current = (let (a, b) =  * _5 in (a, value)) };
    value <- any v;
    assert { [@expl:type invariant] Inv1.inv (let (_, a) =  * _5 in a) };
    assume { Resolve0.resolve (let (_, a) =  * _5 in a) };
    assert { [@expl:type invariant] Inv2.inv _5 };
    assume { Resolve1.resolve _5 };
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve2.resolve self };
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Vecmap_Impl7_GetMut_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = borrowed v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  val get_mut [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 489 4 489 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) : borrowed v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 489 24 489 28] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 489 33 489 39] Inv1.inv result }
    
end
module Vecmap_Impl7_GetMut
  type k
  type v
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv19 with
    type t = Core_Cmp_Ordering_Type.t_ordering
  clone Core_Cmp_Ordering_Type_Inv as Core_Cmp_Ordering_Type_Inv0 with
    predicate Inv0.inv = Inv19.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv18 with
    type t = ()
  clone TyInv_Tuple0 as TyInv_Tuple00 with
    predicate Inv0.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv17 with
    type t = DeepModelTy0.deepModelTy
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv0.inv = Inv17.inv,
    predicate Inv1.inv = Inv19.inv,
    predicate Inv2.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate Inv0.inv = Inv17.inv,
    function LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    predicate Inv1.inv = Inv18.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_SortedRange as SortedRange0 with
    type t = DeepModelTy0.deepModelTy,
    function LeLog0.le_log = LeLog0.le_log
  clone CreusotContracts_Logic_Seq_Impl0_Sorted as Sorted0 with
    type t = DeepModelTy0.deepModelTy,
    predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv16 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (k, v)
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv16.inv,
    axiom .
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv15 with
    type t = Core_Ptr_NonNull_NonNull_Type.t_nonnull (k, v)
  clone Core_Ptr_NonNull_NonNull_Type_Inv as Core_Ptr_NonNull_NonNull_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv15.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Seq.seq (k, v)
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone Vecmap_KeySeqInternal as KeySeqInternal0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function KeySeqInternal0.key_seq_internal = KeySeqInternal0.key_seq_internal
  clone Vecmap_Impl1_Invariant as Invariant2 with
    type k = k,
    type v = v,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate Sorted0.sorted = Sorted0.sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv14 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_VecMap_Type_Inv as Vecmap_VecMap_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv14.inv,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = k,
    predicate Inv0.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Alloc_Alloc_Global_Type.t_global
  clone Alloc_Alloc_Global_Type_Inv as Alloc_Alloc_Global_Type_Inv0 with
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Core_Ptr_Unique_Unique_Type.t_unique (k, v)
  clone Core_Ptr_Unique_Unique_Type_Inv as Core_Ptr_Unique_Unique_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv11.inv,
    predicate Inv1.inv = Inv15.inv,
    predicate Inv2.inv = Inv16.inv,
    axiom .
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl6_Invariant as Invariant1 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv7.inv,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_OccupiedEntry_Type_Inv as Vecmap_OccupiedEntry_Type_Inv0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv10.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Inv1.inv = Inv14.inv,
    predicate Inv2.inv = Inv13.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = (k, v)
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = k,
    type t1 = v,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv13.inv,
    predicate Inv2.inv = Inv1.inv,
    axiom .
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Alloc_RawVec_RawVec_Type.t_rawvec (k, v) (Alloc_Alloc_Global_Type.t_global)
  clone Alloc_RawVec_RawVec_Type_Inv as Alloc_RawVec_RawVec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv11.inv,
    predicate Inv2.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Logic_Seq_Seq_Type_Inv as CreusotContracts_Logic_Seq_Seq_Type_Inv0 with
    type t = (k, v),
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Borrow as TyInv_Borrow3 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Invariant as Invariant0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
  clone TyInv_Borrow as TyInv_Borrow2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed v
  clone TyInv_Borrow as TyInv_Borrow1 with
    type t = v,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (k, v)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = (k, v),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv9.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = v,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (k, v),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Alloc_Vec_Vec_Type_Inv as Alloc_Vec_Vec_Type_Inv0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = (k, v)
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = (k, v),
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv4.inv = Inv7.inv
  let rec cfg get_mut [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 489 4 489 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) : borrowed v
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 489 24 489 28] Inv4.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 489 33 489 39] Inv3.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed v;
  var self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v) = self;
  var _2 : borrowed v;
  var _3 : borrowed v;
  var _4 : borrowed (k, v);
  var _5 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    _5 <- Borrow.borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)));
    self <- { self with current = (let Vecmap_OccupiedEntry_Type.C_OccupiedEntry a b c =  * self in Vecmap_OccupiedEntry_Type.C_OccupiedEntry ({ (Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self)) with current = (let Vecmap_VecMap_Type.C_VecMap a =  * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self) in Vecmap_VecMap_Type.C_VecMap ( ^ _5)) }) b c) };
    assume { Inv0.inv ( ^ _5) };
    _4 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 490 13 490 35] IndexMut0.index_mut _5 (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self)));
    _5 <- any borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
    goto BB1
  }
  BB1 {
    _3 <- Borrow.borrow_mut (let (_, a) =  * _4 in a);
    _4 <- { _4 with current = (let (a, b) =  * _4 in (a,  ^ _3)) };
    assume { Inv1.inv ( ^ _3) };
    _2 <- Borrow.borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _2) };
    assume { Inv1.inv ( ^ _2) };
    _0 <- Borrow.borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Inv1.inv ( ^ _0) };
    assert { [@expl:type invariant] Inv2.inv _4 };
    assume { Resolve0.resolve _4 };
    assert { [@expl:type invariant] Inv3.inv _3 };
    assume { Resolve1.resolve _3 };
    assert { [@expl:type invariant] Inv3.inv _2 };
    assume { Resolve1.resolve _2 };
    assert { [@expl:type invariant] Inv4.inv self };
    assume { Resolve2.resolve self };
    return _0
  }
  
end
module Core_Clone_Clone_Clone_Interface
  type self
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = self
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  val clone' (self : self) : self
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs" 120 14 120 18] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs" 120 4 120 28] Inv1.inv result }
    
end
module Core_Clone_Impls_Impl5_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = usize
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = usize
  val clone' (self : usize) : usize
    requires {[#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs" 181 30 181 34] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    ensures { [#"/home/dominik/.rustup/toolchains/nightly-2023-06-29-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs" 181 20 181 43] Inv1.inv result }
    
end
module Vecmap_Impl15_Clone_Interface
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  val clone' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] result = self }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] Inv1.inv result }
    
end
module Vecmap_Impl15_Clone
  type k
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = usize
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared2 with
    type t = usize,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone1 with
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv3.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  let rec cfg clone' [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] Inv1.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] result = self }
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_KeyRef_Type.t_keyref k = self;
  var _3 : k;
  var _5 : k;
  var _6 : usize;
  var _8 : usize;
  {
    goto BB0
  }
  BB0 {
    _5 <- Vecmap_KeyRef_Type.keyref_key self;
    assert { [@expl:type invariant] Inv0.inv _5 };
    assume { Resolve0.resolve _5 };
    _3 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 499 4 499 14] Clone0.clone' _5);
    goto BB1
  }
  BB1 {
    _8 <- Vecmap_KeyRef_Type.keyref_min_idx self;
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _6 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 500 4 502 18] Clone1.clone' _8);
    goto BB2
  }
  BB2 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _3 _6;
    _3 <- any k;
    _6 <- any usize;
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Vecmap_Impl9_Cloned_Interface
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  val cloned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 517 4 517 36] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 517 18 517 22] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 517 27 517 36] Inv1.inv result }
    
end
module Vecmap_Impl9_Cloned
  type k
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv1 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = k,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg cloned [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 517 4 517 36] [@cfg:stackify] [@cfg:subregion_analysis] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 517 18 517 22] Inv0.inv self}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 517 27 517 36] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self : Vecmap_KeyRef_Type.t_keyref k = self;
  var _3 : k;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _3 <- ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 518 45 518 61] Clone0.clone' (Vecmap_KeyRef_Type.keyref_key self));
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _3 (Vecmap_KeyRef_Type.keyref_min_idx self);
    _3 <- any k;
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl12_From_Interface
  type k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  val from [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 539 4 539 27] (key : k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 539 12 539 15] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 539 23 539 27] Inv1.inv result }
    
end
module Vecmap_Impl12_From
  type k
  use prelude.Int
  use prelude.UIntSize
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  let rec cfg from [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 539 4 539 27] [@cfg:stackify] [@cfg:subregion_analysis] (key : k) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 539 12 539 15] Inv0.inv key}
    ensures { [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 539 23 539 27] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var key : k = key;
  {
    goto BB0
  }
  BB0 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef key ([#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 540 29 540 30] (0 : usize));
    key <- any k;
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl1
  type k
  type v
end
module Vecmap_Impl4
  type k
  type v
end
module Vecmap_Impl6
  type k
  type v
end
module Vecmap_Impl13
  type k
  type v
end
module Vecmap_Impl14
  type k
end
module Vecmap_Impl15
  type k
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone TyInv_Borrow_Shared as TyInv_Borrow_Shared0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  goal clone'_refn : [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 497 15 497 20] forall self : Vecmap_KeyRef_Type.t_keyref k . Inv0.inv self -> Inv0.inv self /\ (forall result : Vecmap_KeyRef_Type.t_keyref k . Inv1.inv result /\ result = self -> Inv1.inv result /\ result = self)
end
module Vecmap_Impl8
  type k
end
module Vecmap_Impl12
  type k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_KeyRef_Type_Inv as Vecmap_KeyRef_Type_Inv0 with
    type k = k,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = k,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  goal from_refn : [#"/mnt/data/projects/creusot/evaluation/vecmap/vecmap.rs" 539 4 539 27] forall value : k . Inv0.inv value -> Inv0.inv value /\ (forall result : Vecmap_KeyRef_Type.t_keyref k . Inv1.inv result -> Inv1.inv result)
end
